# Copyright 2017-today Osoco S.L.
# Distributed under the terms of the GNU General Public License v3
# mod: deploy-aws.dw
# api: public
# txt: Functions useful for deploying CloudFormation stacks in AWS.

DW.import aws-cli;
DW.import aws-cloudformation;

# fun: AWS_DEPLOY.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: AWS_DEPLOY.getModuleName;
# use: echo "Module: ${RESULT}";
function AWS_DEPLOY.getModuleName() {
  export RESULT="AWS_DEPLOY";
  return ${TRUE};
}

# fun: createOrUpdateStack stack action environment client
# api: public
# txt: Creates or updates a stack.
# opt: stack: The stack.
# opt: action: The action.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack gets created successfully; 1/${FALSE} otherwise.
# use: if createOrUpdateStack "network" "create" "pre" "myClient"; then
# use:   echo "Stack network, in environment 'pre', for client' myClient', has been created successfully.";
# use: fi
function createOrUpdateStack() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _action="${2}";
  checkNotEmpty action "${_action}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";

  if ! readSettings "${_stack}" "${_environment}" "${_client}"; then
    exitWithErrorCode MISSING_STACK_SETTINGS "${_stack}";
  fi

  if ! retrieveIndexes "${_stack}"; then
    exitWithErrorCode MISSING_STACK_INDEX "${_stack}";
  fi
  local _stackIndexes="${RESULT}";
  buildStackName "${_stack}" "${_environment}" "${_stackIndexes}" "${_client}";
  export STACK_NAME="${RESULT}";

  if isStackEnabled "${_stack}"; then

    if ! checkStackDeploymentStatus "${_stack}" "${STACK_NAME}" "${_environment}" "${_client}"; then
      exitWithErrorCode ERROR_CHECKING_STACK_STATUS "${STACK_NAME}";
    fi

    local _status="${RESULT}";
    if ! isStackDeployed "${_status}"; then
      retrieveAwsProfile "${_stack}" "${_environment}" "${_client}";
      local _awsProfile="${RESULT}";

      if ! retrieveTemplateFile "${_stack}"; then
        exitWithErrorCode MISSING_TEMPLATE_FILE "${_stack}/${_stack}.json";
      fi
      local _templateFile="${RESULT}";

      if ! isCloudformationTemplateValid "${_templateFile}" "${_awsProfile}" "${_stack}"; then
        exitWithErrorCode INVALID_CLOUDFORMATION_TEMPLATE "${_templateFile}";
      fi

      if ! runDeployPrehook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_PREHOOK_FAILED "${_stack}";
      fi

      displayDeployPreMessage "${_stack}";

      if ! checkDeployPreconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_PRECONDITIONS_NOT_MET "${_stack}";
      fi

      if ! deployStack "${_awsProfile}" "${STACK_NAME}" "${_stack}" "${_templateFile}" "${_action}" "${_environment}" "${_client}"; then
        exitWithErrorCode ERROR_DEPLOYING_STACK "${_stack}";
      fi

      displayDeployPostMessage "${_stack}";

      if ! runDeployPosthook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_POSTHOOK_FAILED "${_stack}";
      fi

      if ! checkDeployPostconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_POSTCONDITIONS_NOT_MET "${_stack}";
      fi
    fi
  else
    logDebug -n "${_stack}";
    logDebugResult NEUTRAL "skipped";
  fi
}

# fun: deleteStack stack environment client
# api: public
# txt: Deletes a stack.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if deleteStack "network" "pre" "myClient"; then
# use:   echo "Stack network, in environment 'pre', for client' myClient', has been deleted successfully.";
# use: fi
function deleteStack() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";

  if ! readSettings "${_stack}" "${_environment}" "${_client}"; then
    exitWithErrorCode MISSING_STACK_SETTINGS "${_stack}";
  fi

  if ! retrieveIndexes "${_stack}"; then
    exitWithErrorCode MISSING_STACK_INDEX "${_stack}";
  fi
  local _stackIndexes="${RESULT}";
  buildStackName "${_stack}" "${_environment}" "${_stackIndexes}" "${_client}";
  export STACK_NAME="${RESULT}";

  if isStackEnabled "${_stack}"; then

    if ! checkStackDeletionStatus "${_stack}" "${STACK_NAME}" "${_environment}" "${_client}"; then
      exitWithErrorCode ERROR_CHECKING_STACK_STATUS "${STACK_NAME}";
    fi

    local _status="${RESULT}";
    if isStackDeleted "${_status}"; then
      logDebug -n "${_stack}";
      logDebugResult SUCCESS "already deleted";
    else
      retrieveAwsProfile "${_stack}" "${_environment}" "${_client}";
      local _awsProfile="${RESULT}";

      if ! runDeletePrehook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_PREHOOK_FAILED "${_stack}";
      fi

      displayDeletePreMessage "${_stack}";

      if ! checkDeletePreconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_PRECONDITIONS_NOT_MET "${_stack}";
      fi

      if ! awsDeleteStack "${_awsProfile}" "${STACK_NAME}" "${_environment}" "${_client}"; then
        exitWithErrorCode ERROR_DELETING_STACK "${_stack}";
      fi

      displayDeletePostMessage "${_stack}";

      if ! runDeletePosthook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_POSTHOOK_FAILED "${_stack}";
      fi

      if ! checkDeletePostconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_POSTCONDITIONS_NOT_MET "${_stack}";
      fi
    fi
  else
    logDebug -n "${_stack}";
    logDebugResult NEUTRAL "skipped";
  fi
}

# fun: awsDeleteStack awsProfile stackName environment client
# api: public
# txt: Requests the deletion of given stack.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if awsDeleteStack "my-profile" "pre-1-my-stack" "pre" "myClient"; then
# use:   echo "pre-1-my-stack deleted successfully in pre";
# use: fi
function awsDeleteStack() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";

  local _region;
  if retrieveAwsRegion "${_stack}" "${_environment}" "${_client}"; then
    _region="${RESULT}";
  else
    _region="eu-west-1";
  fi

  echo 1;
  logTrace "$(which aws) --profile ${_awsProfile} --region ${_region} cloudformation delete-stack --stack-name \"${_stackName}\"";
  echo 2;
  local _output;
  _output="$($(which aws) --profile "${_awsProfile}" --region ${_region} cloudformation delete-stack --stack-name "${_stackName}")";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    logTrace "${_output}";
    waitUntilStackDeletionFinishes "${_stack}" "${_stackName}" "${_environment}" "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: displayDeployPreMessage stack
# api: public
# txt: Displays a message if the stack includes a pre-deployment message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the message exists and is printed; 1/FALSE otherwise.
# use: displayDeployPreMessage base/network;
function displayDeployPreMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/deploy-pre-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/deploy-pre-message.txt";
  fi
}

# fun: displayDeletePreMessage stack
# api: public
# txt: Displays a message if the stack includes a pre-deletion message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the message exists and is printed; 1/FALSE otherwise.
# use: displayDeletePreMessage base/network;
function displayDeletePreMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/delete-pre-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/delete-pre-message.txt";
  fi
}

# fun: checkDeployPreconditions profile environment stack client?
# api: public
# txt: Checks if the deploy preconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the deploy preconditions are met; 1/FALSE otherwise.
# use: if checkDeployPreconditions dev-myclient dev base/network myclient; then
# use:   echo "Deploy preconditions met";
# use: fi
function checkDeployPreconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/deploy-check-preconditions.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/deploy-check-preconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkDeletePreconditions profile environment stack client?
# api: public
# txt: Checks if the delete preconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the delete preconditions are met; 1/FALSE otherwise.
# use: if checkDeletePreconditions dev-myclient dev base/network myclient; then
# use:   echo "Delete preconditions met";
# use: fi
function checkDeletePreconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/delete-check-preconditions.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/delete-check-preconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeployPrehook profile environment stack client?
# api: public
# txt: Runs any pre-deployment hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeployPrehook dev-myclient dev base/network myclient; then
# use:   echo "Deploy pre hook finished successfully";
# use: fi
function runDeployPrehook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/deploy-pre-hook.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/deploy-pre-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeletePrehook profile environment stack client?
# api: public
# txt: Runs any pre-deletement hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeletePrehook dev-myclient dev base/network myclient; then
# use:   echo "Delete pre hook finished successfully";
# use: fi
function runDeletePrehook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/delete-pre-hook.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/delete-pre-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: displayDeployPostMessage stack
# api: public
# txt: Displays a message if the stack includes a post-deployment message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} always.
# use: displayDeployPostMessage base/network;
function displayDeployPostMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/deploy-post-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/deploy-post-message.txt";
  fi
}

# fun: displayDeletePostMessage stack
# api: public
# txt: Displays a message if the stack includes a post-deletement message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} always.
# use: displayDeletePostMessage base/network;
function displayDeletePostMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/delete-post-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/delete-post-message.txt";
  fi
}

# fun: checkDeployPostconditions profile environment stack client?
# api: public
# txt: Checks if the deploy postconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the deploy postconditions are met; 1/FALSE otherwise.
# use: if checkDeployPostconditions dev-myclient dev base/network myclient; then
# use:   echo "Deploy postconditions met";
# use: fi
function checkDeployPostconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/deploy-check-postconditions.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/deploy-check-postconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkDeletePostconditions profile environment stack client?
# api: public
# txt: Checks if the delete postconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the delete postconditions are met; 1/FALSE otherwise.
# use: if checkDeletePostconditions dev-myclient dev base/network myclient; then
# use:   echo "Delete postconditions met";
# use: fi
function checkDeletePostconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/delete-check-postconditions.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/delete-check-postconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeployPosthook profile environment stack client?
# api: public
# txt: Runs any post-deployment hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeployPosthook dev-myclient dev base/network myclient; then
# use:   echo "Deploy post hook finished successfully";
# use: fi
function runDeployPosthook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/deploy-post-hook.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/deploy-post-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeletePosthook profile environment stack client?
# api: public
# txt: Runs any post-deletement hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeletePosthook dev-myclient dev base/network myclient; then
# use:   echo "Delete post hook finished successfully";
# use: fi
function runDeletePosthook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  if fileExists "${_stack}/delete-post-hook.sh"; then
    DW.getDryWitPath;
    "${RESULT}" ${_stack}/delete-post-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: isStackEnabled stack
# api: public
# txt: Checks whether given stack is enabled or not.
# opt: stack: The stack.
# txt: Returns 0/TRUE if the stack is enabled; 1/FALSE otherwise.
# use: if isStackEnabled core; then
# use:   echo "core is enabled";
# use: fi
function isStackEnabled() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  local -i _rescode=${FALSE};

  local _folder="$(basename ${_stack})";
  if fileExists "${_stack}/${_folder}.json"; then
    _rescode=${TRUE};

    local _item;
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _item in $(echo "${OMIT_STACKS}" | sed "s/,/ /g"); do
      IFS="${_oldIFS}";
      if areEqual "${_item}" "${_stack}"; then
        _rescode=${FALSE};
        break;
      fi
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: retrieveDependentStacks stack
# api: public
# txt: Retrieves the dependent stacks.
# opt: stack: The stack name.
# txt: Returns 0/${TRUE} if the dependency analysis succeed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stacks the stack depends on (space-separated values).
# use: if retrieveDependentStacks "dbnetwork"; then
# use:   echo "dbnetwork dependencies: ${RESULT}";
# use: fi
function retrieveDependentStacks() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result="";
  local -i _rescode=${FALSE};
  local _otherStack;

  if fileExists "${_stack}/requirements.yml"; then
    for _otherStack in $(find . -type d | grep -v -e '^\.$' | sed 's ^\./  g' | grep -v -e "^${_stack}$"); do
      grep -e "- ${_otherStack}\W*$" "${_stack}/requirements.yml" > /dev/null;
      local -i _aux=$?;
      if isTrue ${_aux}; then
        _rescode=${TRUE};
        logTrace -n "New dependency found for stack: '${_stack}': ${_otherStack}";
        logTraceResult SUCCESS "${_otherStack}";
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_otherStack}";
      fi
    done
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: deployStack awsProfile stackName stack template action environment client
# api: public
# txt: Requests the deployment of given stack.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: stack: The stack name.
# opt: template: The template file.
# opt: action: Either create or update.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deployed successfully; 1/${FALSE} otherwise.
# use: if deployStack "my-profile" "pre-1-my-stack" "my-stack" "stack.json" create "pre" "myClient"; then
# use:   echo "pre-1-my-stack deployed successfully in pre";
# use: fi
function deployStack() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _template="${4}";
  checkNotEmpty template "${_template}" 4;
  local _action="${5}";
  checkNotEmpty action "${_action}" 5;
  local _environment="${6}";
  checkNotEmpty environment "${_environment}" 6;
  local _client="${7}";

  local _clientTag="";
  if isNotEmpty "${_client}"; then
    _clientTag=" Key=contestia:client,Value=${_client}";
  fi

  local _timestamp="$(date '+%Y%m%d%H%M%S')";
  local -i _rescode=${FALSE};

  local _region;
  if retrieveAwsRegion "${_stack}" "${_environment}" "${_client}"; then
    _region="${RESULT}";
  else
    _region="eu-west-1";
  fi

  if parametersToKeyValuePairs "${_awsProfile}" "${_stackName}" "${_stack}" "${_environment}" "${_client}"; then
    local _parameters="${RESULT}";
    local _escapedParameters="$(echo "${_parameters}" | sed "s |_quote_| ' g")";
    echo 3
    logTrace "$(which aws) --profile ${_awsProfile} --region ${_region} cloudformation create-stack";
    echo 4
    logTrace "--stack-name \"${_stackName}\"";
    logTrace "--tags Key=contestia:name,Value=${_stackName} Key=contestia:stack,Value=${_stackName} Key=contestia:environment,Value=${_environment} Key=vendor,Value=Contestia Key=contestia:deploy:template,Value=${_stack} Key=contestia:deploy:template-version,Value=${GIT_COMMIT} Key=contestia:deploy:timestamp,Value=${_timestamp}${_clientTag}";
    logTrace "--template-body file://${_template}";
    logTrace "--parameters ${_escapedParameters}";
    logTrace "--capabilities CAPABILITY_NAMED_IAM;";

    local _output;
    createTempFile;
    local _tmpFile="${RESULT}";
    echo 5
    cat <<EOF > "${_tmpFile}"
#!/bin/sh

$(which aws) --profile ${_awsProfile} --region ${_region} cloudformation ${_action}-stack --stack-name ${_stackName} --tags Key=contestia:name,Value=${_stackName} Key=contestia:environment,Value=${_environment} Key=vendor,Value=Contestia Key=contestia:deploy:template,Value=${_stack} Key=contestia:deploy:template-version,Value=${GIT_COMMIT} Key=contestia:deploy:timestamp,Value=${_timestamp}${_clientTag} --template-body file://${_template} --parameters ${_escapedParameters} --capabilities CAPABILITY_NAMED_IAM;
EOF
    echo 6
    chmod +x "${_tmpFile}";
    _output="$(${_tmpFile})";
    _rescode=$?;
  fi

  if isTrue ${_rescode}; then
    logTrace "${_output}";
    waitUntilStackDeploymentFinishes "${_stack}" "${_stackName}" "${_environment}" "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: isStackCreated stack environment client
# api: public
# txt: Checks whether given stack is created already.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client.
# txt: Returns 0/${TRUE} if the stack is created correctly; 1/${FALSE} otherwise.
# use: if isStackCreated "network" "pre" "myclient"; then
# use:   echo "Stack network in 'pre', for 'myclient', is created";
# use: fi
function isStackCreated() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local -i _rescode=${FALSE};

  local _stackIndexes;

  if retrieveIndexes "${_stack}"; then
    _stackIndexes="${RESULT}";
  else
    exitWithErrorCode MISSING_INDEX_FOR_STACK "${_stack}";
  fi

  buildStackName "${_stack}" "${_environment}" "${_stackIndexes}" "${_client}";
  local _stackName="${RESULT}";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _status="${RESULT}";
    if isStackDeployed "${_status}"; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: isStackDeployed status
# api: public
# txt: Checks whether the stack is already deployed.
# opt: status: The stack status.
# txt: Returns 0/TRUE if the stack is deployed; 1/FALSE otherwise.
# use: if isStackDeployed ${status}; then
# use:   echo "Stack deployed";
# use: fi
function isStackDeployed() {
  local _status="${1}";
  checkNotEmpty status "${_status}" 1;

  local -i _rescode;

  if    areEqual "${_status}" CREATE_COMPLETE \
     || areEqual "${_status}" UPDATE_COMPLETE; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};

}

# fun: isStackDeleted status
# api: public
# txt: Checks whether the stack is already deleted.
# opt: status: The stack status.
# txt: Returns 0/TRUE if the stack is deleted; 1/FALSE otherwise.
# use: if isStackDeleted ${status}; then
# use:   echo "Stack deleted";
# use: fi
function isStackDeleted() {
  local _status="${1}";
  checkNotEmpty status "${_status}" 1;

  local -i _rescode;

  if areEqual "${_status}" DELETE_COMPLETE; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};

}

# fun: retrieveStackStatus stack environment stackFullName client
# api: public
# txt: Retrieves the status of a given stack.
# opt: stack: The stack name.
# opt: stackFullName: The full stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the status could be queried; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack status.
# use: if retrieveStackStatus "01-network" "pre-myClient-01-network" "pre" "myClient"; then
# use:   echo "pre-client-01-network status -> ${RESULT}";
# use: fi
function retrieveStackStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackFullName="${2}";
  checkNotEmpty stackFullName "${_stackFullName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${FALSE};
  local _result;
  local _awsProfile;

  if retrieveAwsProfile "${_stack}" "${_environment}" "${_client}"; then
    _awsProfile="${RESULT}";
  else
    exitWithErrorCode CANNOT_USE_AWS_CLI;
  fi

  local _region;
  if retrieveAwsRegion "${_stack}" "${_environment}" "${_client}"; then
    _region="${RESULT}";
  else
    _region="eu-west-1";
  fi

  if checkCloudformationStackStatus "${_stackFullName}" "${_region}" "${_awsProfile}"; then
    _rescode=${TRUE};
    _result="${RESULT:-unknown}";
    if areEqual "${_result}" 'User Initiated'; then
      _result="CREATE_IN_PROGRESS";
    fi
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: checkStackDeploymentStatus stack stackName environment
# api: public
# txt: Checks the status of the stack.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack could be checked; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the status reported by AWS.
# use: if checkStackDeploymentStatus "my-stack" "client-my-stack" "pre" "${CLIENT}"; then
# use:   echo "Stack status -> ${RESULT}";
# use: fi
function checkStackDeploymentStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local _result;

  logTrace -n "Retrieving the status of ${_stack} (${_stackName})";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _result="${RESULT}";

    if isStackDeployed "${_result}"; then
      logTraceResult SUCCESS "${_result}";
    else
      logTraceResult FAILURE "${_result}";
    fi
    export RESULT="${_result}";
  else
    logTraceResult FAILURE "missing";
  fi

  return ${TRUE};
}

# fun: checkStackDeletionStatus stack stackName environment
# api: public
# txt: Checks the status of the stack.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack could be checked; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the status reported by AWS.
# use: if checkStackDeletionStatus "my-stack" "client-my-stack" "pre" "${CLIENT}"; then
# use:   echo "Stack status -> ${RESULT}";
# use: fi
function checkStackDeletionStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local _result;

  logTrace -n "Retrieving the status of ${_stack} (${_stackName})";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _result="${RESULT}";

    if isStackDeleted "${_result}"; then
      logTraceResult SUCCESS "${_result}";
    else
      logTraceResult FAILURE "${_result}";
    fi
  else
    logTraceResult FAILURE "missing";
  fi

  export RESULT="${_result}";

  return ${TRUE};
}

# fun: waitUntilStackDeploymentFinishes stack stackName environment
# api: public
# txt: Waits until the stack is created or gets rolled back.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets created successfully; 1/${FALSE} otherwise.
# use: if waitUntilStackDeploymentFinishes "my-stack" "pre" "${CLIENT}"; then
# use:   echo "my-stack has been created successfully in pre";
# use: fi
function waitUntilStackDeploymentFinishes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${FALSE};
  local _status;

  logInfo -n "Waiting for ${_stackName} to deploy ";
  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    _status="${RESULT}";

    while ! isStackDeployed "${_status}"; do
      if areEqual "${_status}" ROLLBACK_COMPLETE; then
        _rescode=${FALSE};
        break;
      fi
      sleep ${STACK_CHECK_INTERVAL};
      if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
        _status="${RESULT}";
        _rescode=${TRUE};
      else
        _rescode=${FALSE};
        break;
      fi
    done
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "${_status}";
  else
    logInfoResult FAILURE "${_status}";
  fi

  return ${_rescode};
}

# fun: waitUntilStackDeletionFinishes stack stackName environment
# api: public
# txt: Waits until the stack is deleted.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if waitUntilStackDeletionFinishes "my-stack" "pre" "${CLIENT}"; then
# use:   echo "my-stack has been deleted successfully in pre";
# use: fi
function waitUntilStackDeletionFinishes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${FALSE};
  local _status;

  logInfo -n "Waiting for ${_stackName} to be deleted";
  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    _status="${RESULT}";

    while ! isStackDeleted "${_status}"; do
      if areEqual "${_status}" DELETE_ROLLBACK_COMPLETE; then
        _rescode=${FALSE};
        break;
      fi
      sleep ${STACK_CHECK_INTERVAL};
      if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
        _status="${RESULT}";
        _rescode=${TRUE};
      else
        _rescode=${FALSE};
        break;
      fi
    done
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "${_status}";
  else
    logInfoResult FAILURE "${_status}";
  fi

  return ${_rescode};
}

# fun: readSettings stack environment
# api: public
# txt: Reads stack settings.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the settings are read successfully; 1/${FALSE} otherwise.
# use: if readSettings "my-stack" "pre" "myClient"; then
# use:   echo "my-stack settings read successfully";
# use: fi
function readSettings() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local -i _rescode=${TRUE};
  local _f;

  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    local _configFiles="${RESULT}";
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _f in ${_configFiles}; do
      IFS="${_oldIFS}";
      if fileExists "${_f}"; then
        logTrace -n "Reading ${_f} file";
        source ${_f} 2> /dev/null;
        _rescode=$?;
        if isTrue ${_rescode}; then
          logTraceResult SUCCESS "done";
        else
          logTraceResult FAILURE "failed";
          break;
        fi
      fi
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: retrieveTemplateFile stack
# api: public
# txt: Retrieves the template file.
# opt: stack: The stack name.
# txt: Returns 0/${TRUE} if the template file exists; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the path of the template file.
# use: if retrieveTemplateFile "network"; then
# use:   echo "Template file -> ${RESULT}";
# use: else
# use:   echo "Template file for 'network' not found";
# use: fi
function retrieveTemplateFile() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  local _folder="$(basename ${_stack})";
  _result="${_stack}/${_folder}.json";
  if fileExists "${_result}"; then
    if minify_json_file "${_result}"; then
      # RESULT is already exported by minify_json_file
      _rescode=${TRUE};
    else
      exitWithErrorCode CANNOT_MINIFY_TEMPLATE "${_result}";
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode};
}

# fun: minify_json_file input
# api: public
# txt: Minifies given JSON file.
# opt: input: The JSON to minify.
# txt: Returns 0/${TRUE} if the JSON gets minified; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the path of the minified file.
# use: if minify_json_file "/tmp/my-file.json"; then
# use:   echo "Minified file -> ${RESULT}";
# use: else
# use:   echo "Cannot minify /tmp/my-file.json";
# use: fi
function minify_json_file() {
  local _input="${1}";
  checkNotEmpty input "${_input}" 1;
  local _result;
  local -i _rescode;

  if createTempFile; then
    _result="${RESULT}";

    jq -c . < "${_input}" > "${_result}" 2> /dev/null
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  else
    logInfo "Error minifying ${_input}";
    jq -c . < "${_input}"
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: buildStackName stack environment indexes client?
# api: public
# txt: Builds the final name for the stack.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: indexes: The stack indexes. If multiple, pass them as a single argument.
# opt: client: The client. Can be empty.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the final name of the stack.
# use: buildStackName "network" "pre" 1 "my_client";
# use: echo "Final name: ${RESULT}";
function buildStackName() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _indexes="${3}";
  checkNotEmpty indexes "${_indexes}" 3;
  local _client="${4}";
  local _result="${_environment}";

  if isNotEmpty "${_client}" && isNotEmpty "${OMIT_CLIENT_IN_STACK_NAME}" && isFalse ${OMIT_CLIENT_IN_STACK_NAME}; then
    _result="${_result}-${_client}";
  fi

  if isNotEmpty "${OMIT_CONTESTIA_IN_STACK_NAME}" && isFalse ${OMIT_CONTESTIA_IN_STACK_NAME}; then
    _result="${_result}-contestia";
  fi

  local _indexArray=(${_indexes});
  local _stackArray=($(echo ${_stack} | sed 's|/| |g'));

  local _pieces="$(echo ${_stack} | awk -F'/' '{print NF;}')";
  local _piece;
  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  for _piece in $(seq 0 $((_pieces-1))); do
    retrieveNthIndexOfPath "${_stack}" ${_piece};
    local _index="${RESULT}";
    _result="${_result}-${_index}-${_stackArray[${_piece}]}";
  done

  export RESULT="${_result}";
}

# fun: retrieveIndex stack
# api: public
# txt: Retrieves the stack index.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the stack index could be guessed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack index.
# use: if retrieveIndex "network"; then
# use:   echo "Stack index for 'network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the stack index for 'network'";
# use: fi
function retrieveIndex() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  if fileExists "${_stack}/index"; then
    _result="$(cat "${_stack}/index")";
    if isNotEmpty "${_result}"; then
      _rescode=${TRUE};
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveIndexes stack
# api: public
# txt: Retrieves the stack index.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the stack index could be guessed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack index.
# use: if retrieveIndexes "network"; then
# use:   echo "Stack indexes for 'network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the stack index for 'network'";
# use: fi
function retrieveIndexes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  if retrieveIndex "${_stack}"; then
    local -i _pieces="$(echo "${_stack}" | awk -F'/' '{print NF};')";

    for _piece in $(seq 1 ${_pieces}); do
      local _category="$(echo "${_stack}" | awk -F'/' -v pos=${_piece} '{ for(i=1;i<=pos;i++){ printf("%s/", $i); }}' | sed 's /$  g')";
      if    isNotEmpty "${_category}" \
         && retrieveIndex "${_category}"; then
        _rescode=${TRUE};
        local _index="${RESULT}";
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_index}";
      else
        break;
      fi
    done
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveNthIndexOfPath path nth
# api: public
# txt: Retrieves the nth index of given path.
# opt: path: The path.
# opt: nth: The nth position we are interested in (0-based).
# txt: Returns 0/${TRUE} if the index could be extracted; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the index.
# use: if retrieveNthIndexOfPath "base/network" 2; then
# use:   echo "Index for 'network' in 'base/network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the index for 'network' in 'base/network'";
# use: fi
function retrieveNthIndexOfPath() {
  local _path="${1}";
  checkNotEmpty path "${_path}" 1;
  local _nth="${2}";
  checkNotEmpty nth "${_nth}" 2;
  checkNumber nth "${_nth}" 2;

  local _result;
  local -i _rescode=${FALSE};

  local -i _pieces="$(echo "${_path}" | awk -F'/' '{print NF};')";

  local _category="$(echo "${_path}" | awk -F'/' -v pos=$((_nth+1)) '{ for(i=1;i<=pos;i++){ printf("%s/", $i); }}' | sed 's /$  g')";
  if    isNotEmpty "${_category}" \
     && retrieveIndex "${_category}"; then
    _rescode=${TRUE};
    _result="${RESULT}";
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveAwsProfile stack enviroment client?
# api: public
# txt: Retrieves the AWS profile.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if the profile was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AWS profile.
# use: if retrieveAwsProfile "network" "${ENVIRONMENT}" "${CLIENT}"; then
# use:   echo "Using profile ${RESULT}";
# use: fi
function retrieveAwsProfile() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local _result;
  local _aux;
  local -i _rescode=${FALSE};
  local _f;
  local _oldIFS="${IFS}";

  AWS_DEPLOY.getCachedAwsProfile;
  local _cachedAwsProfile="${RESULT}";

  if isEmpty "${_cachedAwsProfile}"; then
    if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
      local _configFiles="${RESULT}";
      IFS="${DWIFS}";
      for _f in ${_configFiles}; do
        IFS="${_oldIFS}";
        logTrace -n "Looking for profile information in ${_f}";
        _result="$(grep -e "^AWS_PROFILE=" "${_f}" | awk -F'=' '{print $2}')";
        _rescode=$?;
        if isTrue ${_rescode}; then
          logTraceResult SUCCESS "${_result}";
          break;
        else
          logTraceResult FAILURE "not found";
        fi
      done
      IFS="${_oldIFS}";
    fi

    if isTrue ${_rescode}; then
      export RESULT="${_result}";
    else
      normalizeUppercase "${_environment}_${_client}";
      _envUpcased="${RESULT}";
      logTrace -n "Retrieving the default profile for ${_environment} environment (${_envUpcased}_AWS_PROFILE)";
      local -n _aux="${_envUpcased}_AWS_PROFILE";
      _result="${_aux}";
      if isEmpty "${_result}"; then
        logTraceResult NEUTRAL "missing";
        _rescode=${FALSE};
      else
        logTraceResult SUCCESS "${_result}";
        export RESULT="${_result}";
        _rescode=${TRUE};
      fi
    fi
    AWS_DEPLOY.setCachedAwsProfile "${_result}";
  else
    export RESULT="${_cachedAwsProfile}";
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: retrieveAwsRegion stack environment client?
# api: public
# txt: Retrieves the AWS profile.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if the AWS region could be retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AWS region.
# use: if retrieveAwsRegion "network" "${ENVIRONMENT}" "${CLIENT}"; then
# use:   echo "Using region ${RESULT}";
# use: fi
function retrieveAwsRegion() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local _result;
  local _aux;
  local -i _rescode;
  local _f;

  AWS_DEPLOY.getCachedAwsRegion;
  local _cachedAwsRegion="${RESULT}";

  if isEmpty "${_cachedAwsRegion}"; then
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
      local _configFiles="${RESULT}";
      for _f in ${_configFiles}; do
        IFS="${_oldIFS}";
        logTrace -n "Looking for region information in ${_f}";
        _result="$(grep -e "^AWS_REGION=" "${_f}" | awk -F'=' '{print $2;}')";
        _rescode=$?;
        if isTrue ${_rescode}; then
          logTraceResult SUCCESS "${_result}";
          break;
        else
          logTraceResult FAILURE "not found";
        fi
      done
      IFS="${_oldIFS}";
    fi

    if isTrue ${_rescode}; then
      export RESULT="${_result}";
    else
      normalizeUppercase "${_environment}_${_client}";
      _envUpcased="${RESULT}";
      logTrace -n "Retrieving the default region for ${_environment} environment (${_envUpcased}_AWS_REGION)";
      local -n _aux="${_envUpcased}_AWS_REGION";
      _result="${_aux}";
      if isEmpty "${_result}"; then
        logTraceResult NEUTRAL "missing"
	      logTrace -n "Using 'eu-west-1' as default region"
	      export RESULT="eu-west-1";
        _rescode=${TRUE};
      else
        logTraceResult SUCCESS "${_result}";
        export RESULT="${_result}";
        _rescode=${TRUE};
      fi
    fi
    AWS_DEPLOY.setCachedAwsRegion "${_result}";
  else
    export RESULT="${_cachedAwsRegion}";
    _rescode=${TRUE};
  fi

  return ${_rescode};
}

# fun: retrieveConfigFiles stack environment client?
# api: public
# txt: Retrieves the ordered list of the config files for given stack.
# opt: stack: The name of the stack.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if at least one config file is found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains a space-separated list of config files.
# use: if retrieveConfigFiles "network" "pre" "client1"; then
# use:   echo "Config files: ${RESULT}";
# use: fi
function retrieveConfigFiles() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";

  local -i _rescode=${FALSE};
  local _result="";
  local _oldIFS="${IFS}";
  local _f;

  AWS_DEPLOY.getCachedConfigFiles;
  local _cachedConfigFiles="${RESULT}";

  if isEmpty "${_cachedConfigFiles}"; then
    local _folder="$(basename ${_stack})";
    IFS="${DWIFS}";
    for _f in default.config \
                ${_stack}/${_folder}.config \
                ${_environment}.config \
                ${_stack}/${_environment}.config \
                ${_client}.config \
                ${_environment}-${_client}.config \
                ${_stack}/${_client}.config \
                ${_stack}/${_environment}-${_client}.config; do
      IFS="${_oldIFS}";
      logTrace -n "Checking if ${_f} exists";
      if fileExists "${_f}"; then
        logTraceResult SUCCESS "present";
        _rescode=${TRUE};
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_f}";
      else
        logTraceResult NEUTRAL "missing";
      fi
    done;
    IFS="${_oldIFS}";
    AWS_DEPLOY.setCachedConfigFiles "${_result}";
  else
    _result="${_cachedConfigFiles}";
    _rescode=${TRUE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveOptimizedAmiFamily ec2InstanceType
# api: public
# txt: Retrieves the optimized AMI family of the EC2 instances based on their instance type.
# opt: ec2InstanceType: The EC2 instance type. Optional.
# txt: Returns 0/${TRUE} always.
# txt: The variable RESULT contains either "amazon-linux-2", "amazon-linux-2/arm64", "amazon-linux-2/gpu" or "amazon-linux-2/inf".
# use: if retrieveOptimizedAmiFamily "t2.medium"; then
# use:   echo "Optimized AMI family: ${RESULT}";
# use: fi
function retrieveOptimizedAmiFamily() {
  local _instanceType="${1}";

  local _result="amazon-linux-2";

  if isNotEmpty "${_instanceType}"; then
    if contains "${_instanceType}" "a1."; then
      _result="amazon-linux-2/arm64";
    elif contains "${_instanceType}" "m6g."; then
      _result="amazon-linux-2/arm64";
    fi
  fi

  export RESULT="${_result}";

  return ${TRUE};
}

# fun: parametersToKeyValuePairs stackName stack environment client?
# api: public
# txt: Converts the stack parameters to key=value pairs, key in camel case.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack parameters could be converted; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the pairs of all parameters defined in deploy-stack.inc.sh.
# use: if parametersToKeyValuePairs "my-profile" "pre-groucho-1-network" "network" "pre" "client1"; then
# use:   echo "'network' parameters: ${RESULT}";
# use: fi
function parametersToKeyValuePairs() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _environment="${4}";
  checkNotEmpty environment "${_environment}" 4;
  local _client="${5}";
  local _otherStacks;
  local _otherStack;
  local _otherStackIndexes;
  local _otherStackName;
  local _camelCasedStackName;
  local _result="";
  local _inputFiles="";
  local -i _rescode;
  local _auxFile;
  local _f;

  _result="ParameterKey=Environment,ParameterValue=${_environment}";
#  _result="ParameterKey=StackName,ParameterValue=${_stackName}";
  if retrieveDependentStacks "${_stack}"; then
    local _dependentStacks="${RESULT}";
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _otherStack in ${_dependentStacks}; do
      IFS="${_oldIFS}";
      retrieveIndexes "${_otherStack}";
      _otherStackIndexes="${RESULT}";
      if isEmpty "${_otherStackIndexes}"; then
        exitWithErrorCode MISSING_STACK_INDEX "${_otherStack}";
      else
        buildStackName "${_otherStack}" "${_environment}" "${_otherStackIndexes}" "${_client}";
        _otherStackName="${RESULT}";
        toCamelCase "$(echo ${_otherStack} | tr '[A-Z]' '[a-z]')_stack_name";
        _camelCasedStackName="${RESULT}";
        _result="${_result} ParameterKey=${_camelCasedStackName},ParameterValue=${_otherStackName}";
      fi
    done
    IFS="${_oldIFS}";
  fi

  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    _inputFiles="${RESULT}";
    createTempFile;
    _auxFile="${RESULT}";

    IFS="${DWIFS}";
    for _f in ${_inputFiles}; do
      IFS="${_oldIFS}";
      cat ${_f} >> ${_auxFile};
      echo >> ${_auxFile}
    done
    IFS="${_oldIFS}";

    if grep "AMI_ID" "${_auxFile}" 2>&1 > /dev/null; then
      if retrieveAwsRegion "${_stack}" "${_environment}" "${_client}"; then
        local _region="${RESULT}";
        local _ec2InstanceType="$(grep "EC2_INSTANCE_TYPE" "${_auxFile}")";
        retrieveOptimizedAmiFamily "${_ec2InstanceType}";
        local _ec2Architecture="${RESULT}";
        if retrieveOptimizedAmiId "${_awsProfile}" "${_region}" "${_ec2Architecture}"; then
          local _amiId="${RESULT}";
          _result="${_result} ParameterKey=AmiId,ParameterValue=${_amiId}";
        fi
      fi
    fi

    _result="${_result} $(cat "${_auxFile}" | grep -v AMI_ID | sort -u | uniq | grep -v -e '^#' | grep -v -e '^\s*$' | grep -v 'AWS_PROFILE' | awk -F'=' -v quote="'" '{if (keys[$1] == null || length(keys[$1] == 0)) {print $0;}; keys[$1]=$1;}' | awk -F'=' 'function toCamel(s) { camel = ""; split(s, words, /-|[^a-zA-Z0-9]/); for (i = 1; i in words; i++){camel = camel toupper(substr(words[i], 1, 1)) tolower(substr(words[i], 2)) }; return camel } { gsub(/"/, "", $2); gsub(/^/, quote, $2); gsub(/$/, quote, $2); printf(" ParameterKey=%s,ParameterValue=|_quote_|%s|_quote_|", toCamel($1), $2);}')";
  fi

  export RESULT="${_result}";
}

# fun: retrieveOptimizedAmiId awsProfile region
# api: public
# txt: Retrieves the id of the optimized AMI for given region.
# opt: awsProfile: The AWS profile.
# opt: region: The region.
# txt: Returns 0/TRUE if the id could be retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AMI id.
# use: if retrieveOptimizedAmiId "mine" "us-east-1"; then
# use:   echo "AMI ID: ${RESULT}";
# use: fi
function retrieveOptimizedAmiId() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _region="${2}";
  checkNotEmpty region "${_region}" 2;
  local _family="${3}";
  checkNotEmpty family "${_family}" 3;

  local _type;

  local _result;

  echo 7
  _result="$($(which aws) --profile "${_awsProfile}" ssm get-parameters --names /aws/service/ecs/optimized-ami/${_family}/recommended/image_id --region "${_region}" | jq '. | .Parameters[].Value' | tr -d '"')";
  local -i _rescode=$?;
  echo 8
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveStacksInCategory category
# api: public
# txt: Retrieves the stacks in given category.
# opt: category: The category.
# txt: Returns 0/TRUE if there's any stack in given category.
# txt: If the function returns 0/TRUE, the variable RESULT contains the space-separated list of stacks.
# use: if retrieveStacksInCategory myCategory; then
# use:   echo "Stacks in myCategory: ${RESULT}";
# use: fi
function retrieveStacksInCategory() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;

  local -i _rescode=${FALSE};
  local _result;

  local _potentialStacks="$(find ${_category} -maxdepth 1 -type d | sed "s ${_category}/  g" | grep -v -e "^${_category}$")";
  local _potentialStack;
  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  for _potentialStack in ${_potentialStacks}; do
    IFS="${_oldIFS}";
    if fileExists "${_category}/${_potentialStack}/index"; then
      _rescode=${TRUE};
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_potentialStack}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveStackChain
# api: public
# txt: Retrieves the stack chain.
# txt: Returns 0/${TRUE} if the stack chain could be retrieved; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack chain.
# use: if retrieveStackChain; then
# use:   echo "The stack chain is ${RESULT}";
# use: fi
function retrieveStackChain() {
  local _result;
  local -i _rescode=${FALSE};

  if retrieveCachedStackChain; then
    _rescode=${TRUE};
    _result="${RESULT}";
  else
    if retrieveCategories; then
      local _categories="${RESULT}";
      createTempFile;
      local _auxFile="${RESULT}";

      local _category;
      local _categoryIndex=0;
      local _oldIFS="${IFS}";
      IFS="${DWIFS}";
      for _category in ${_categories}; do
        IFS="${_oldIFS}";

        if retrieveIndex "${_category}"; then
          _categoryIndex="${RESULT}";
        else
          exitWithErrorCode CANNOT_RETRIEVE_CATEGORY_INDEX "${_category}";
        fi

        local _stacks="";
        if retrieveStacksInCategory "${_category}"; then
          local _categoryStacks="${RESULT}";
          if isNotEmpty "${_categoryStacks}"; then
            _stacks="${_stacks} ";
          fi
          _stacks="${_stacks}${_categoryStacks}";
        else
          exitWithErrorCode NO_STACKS_IN_CATEGORY_FOUND "${_category}";
        fi
        IFS="${DWIFS}";
        for _stack in ${_stacks}; do
          IFS="${_oldIFS}";
          if isStackEnabled "${_category}/${_stack}"; then
            if retrieveIndexes "${_category}/${_stack}"; then
              local _stackIndex="";
              _stackIndexes="${RESULT}";
              local _index;
              IFS="${DWIFS}";
              for _index in ${_stackIndexes}; do
                IFS="${_oldIFS}";
                if isNotEmpty "${_index}"; then
                  if isNotEmpty "${_stackIndex}"; then
                    _stackIndex="${_stackIndex}-";
                  fi
                  _stackIndex="${_stackIndex}${_index}";
                fi
              done
              IFS="${_oldIFS}";
            fi
            cat <<EOF >> "${_auxFile}"
${_stackIndex}=${_category}/${_stack}
EOF
          fi
        done
        IFS="${_oldIFS}";
      done

      _result="$(sort "${_auxFile}" | awk -F'=' '{print $2;}')";
      _rescode=$?;
      buildStackChainCacheFilename;
      local _stackOrderFile="${RESULT}";
      sort "${_auxFile}" | awk -F'=' '{print $2;}' > "${_stackOrderFile}";
    else
      exitWithErrorCode NO_CATEGORIES_FOUND;
    fi
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: deployAll
# api: public
# txt: Manages the deployment of all stacks as a whole.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: deployAll;
function deployAll() {
  local _stack;

  local _oldIFS="${IFS}";
  local _file;
  IFS="${DWIFS}";
  for _file in .deploy-stack.inc.sh \
               .deploy-stack.inc.sh.${CLIENT}-${ENVIRONMENT} \
               .deploy-all.inc.sh.${CLIENT}-${ENVIRONMENT}; do
    IFS="${_oldIFS}";
    if fileExists "${_file}"; then
      source "${_file}";
    fi
  done
  IFS="${_oldIFS}";

  if retrieveStackChain; then
    local _chain="${RESULT}";

    if retrieveLastFailedToDeployStack; then
      local _lastStack="${RESULT}";
      if retrieveStacksPendingToDeploy "${_lastStack}" "${_chain}"; then
        _chain="${RESULT}";
      fi
    fi

    IFS="${DWIFS}";
    for _stack in ${_chain}; do
      IFS="${_oldIFS}";
      if isStackCreated "${_stack}" "${ENVIRONMENT}" "${CLIENT}"; then
        logInfo -n "${_stack}";
        logInfoResult NEUTRAL "deployed";
      else
        cacheStackAsNotDeployed "${_stack}";
        if createOrUpdateStack "${_stack}" "${ACTION}" "${ENVIRONMENT}" "${CLIENT}"; then
          cacheStackAsSuccessfullyDeployed "${_stack}";
        fi
      fi
      AWS_DEPLOY.defaultState;
    done
    IFS="${_oldIFS}";
  else
    exitWithErrorCode CANNOT_RETRIEVE_THE_STACK_CHAIN;
  fi
}

# fun: retrieveStacksPendingToDeploy stack chain
# api: public
# txt: Retrieves the remaning stacks after the one given, in the chain.
# opt: stack: The first stack to consider in the chain.
# opt: chain: The stack chain.
# txt: Returns 0/TRUE if the stack was in the chain; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the last part of the chain, starting with given stack.
# use: if retrieveStacksPendingToDeploy "permissions" "${CHAIN}"; then
# use:   echo "Remaining: ${RESULT}";
# use: fi
function retrieveStacksPendingToDeploy() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _chain="${2}";
  checkNotEmpty chain "${_chain}" 2;

  local -i _rescode=${FALSE};
  local _result;

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _item;
  local -i _includeItem=${FALSE};

  for _item in ${_chain}; do
    IFS="${_oldIFS}";
    if areEqual "${_item}" "${_stack}"; then
      _includeItem=${TRUE};
      _rescode=${TRUE};
    fi
    if isTrue ${_includeItem}; then
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_item}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveLastFailedToDeployStack
# api: public
# txt: Retrieves the last stack that failed to deploy.
# txt: Returns 0/TRUE if some stack failed to deploy; 1/FALSE otherwise.
# txt: If the function returs 0/TRUE, the variable RESULT contains the failed stack.
# use: if retrieveLastFailedToDeployStack; then
# use:   echo "Retrying ${RESULT}";
# use: fi
function retrieveLastFailedToDeployStack() {
  local -i _rescode=${FALSE};
  local _result;

  buildLastFailedToDeployStackCacheFilename;
  local _cacheFile="${RESULT}";
  if fileExists "${_cacheFile}"; then
    _result="$(cat "${_cacheFile}" 2> /dev/null)";
    _rescode=$?;
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: cacheStackAsNotDeployed stack.
# api: public
# txt: Writes the name of the last failed stack to disk as cache.
# opt: stack: The stack name.
# txt: Returns 0/TRUE if the name of the last failed stack could be cached.
# use: if cacheStackAsNotDeployed myStack; then
# use:   echo "myStack annotated as not yet deployed";
# use: fi
function cacheStackAsNotDeployed() {
   local _stack="${1}";
   checkNotEmpty stack "${_stack}" 1;

   local -i _rescode=${FALSE};

   buildLastFailedToDeployStackCacheFilename;
   local _stackFile="${RESULT}";
   cat <<EOF > "${_stackFile}";
${_stack}
EOF

   return ${_rescode};
 }

# fun: cacheStackAsNotDeleted stack.
# api: public
# txt: Writes the name of the stack last failed to delete to disk as cache.
# opt: stack: The name of the stack.
# txt: Returns 0/TRUE if the name of the last failed stack could be cached.
# use: if cacheStackAsNotDeleted "myStack"; then
# use:   echo "myStack annotated as not yet deployed";
# use: fi
function cacheStackAsNotDeleted() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  local -i _rescode=${FALSE};

  buildLastFailedToDeleteStackCacheFilename;
  local _stackFile="${RESULT}";
  cat <<EOF > "${_stackFile}";
${_stack}
EOF

  return ${_rescode};
}

# fun: cacheStackAsSuccessfullyDeployed
# api: public
# txt: Ensures given stack is annotated as not failed in the cache.
# txt: Returns 0/TRUE always.
# use: cacheStackAsSuccessfullyDeployed "permissions";
function cacheStackAsSuccessfullyDeployed() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  buildLastFailedToDeployStackCacheFilename;
  local _stackFile="${RESULT}";
  if cat "${_stackFile}" 2> /dev/null | grep "${_stack}" > /dev/null; then
    echo -n '' > "${_stackFile}";
  fi

  return ${TRUE};
}

# fun: cacheStackAsSuccessfullyDeleted
# api: public
# txt: Ensures given stack is annotated as deleted in the cache.
# txt: Returns 0/TRUE always.
# use: cacheStackAsSuccessfullyDeleted "permissions";
function cacheStackAsSuccessfullyDeleted() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  buildLastFailedToDeleteStackCacheFilename;
  local _stackFile="${RESULT}";
  if cat "${_stackFile}" 2> /dev/null | grep "${_stack}" > /dev/null; then
    echo -n '' > "${_stackFile}";
  fi

  return ${TRUE};
}

# fun: buildLastFailedToDeployStackCacheFilename
# api: public
# txt: Builds the filename of the last failed to deploy stack cache.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the filename.
# use: buildLastFailedToDeployStackCacheFilename;
# use: echo "Last failed stack cache file: ${RESULT}";
function buildLastFailedToDeployStackCacheFilename() {
  export RESULT=".last-failed-to-deploy-stack-${ENVIRONMENT}-${CLIENT}";
}

# fun: deleteAll
# api: public
# txt: Manages the deployment of all stacks as a whole.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: deployAll;
function deleteAll() {
  local _stack;

  local _oldIFS="${IFS}";
  local _file;
  IFS="${DWIFS}";
  for _file in .deploy-stack.inc.sh \
               .deploy-stack.inc.sh.${CLIENT}-${ENVIRONMENT} \
               .deploy-all.inc.sh.${CLIENT}-${ENVIRONMENT}; do
    IFS="${_oldIFS}";
    if fileExists "${_file}"; then
      source "${_file}";
    fi
  done
  IFS="${_oldIFS}";

  if retrieveStackChain; then
    local _chain="${RESULT}";

    if retrieveLastFailedToDeleteStack; then
      local _lastStack="${RESULT}";
      if retrieveStacksPendingToDelete "${_lastStack}" "${_chain}"; then
        _chain="$(echo ${RESULT} | tr -s ' ' '\n' | tac)";
      fi
    fi

    IFS="${DWIFS}";
    for _stack in $(echo ${_chain} | tr -s ' ' '\n' | tac); do
      IFS="${_oldIFS}";
      if isStackDeleted "${_stack}" "${ENVIRONMENT}" "${CLIENT}"; then
        logInfo -n "${_stack}";
        logInfoResult NEUTRAL "deleted";
      else
        cacheStackAsNotDeleted "${_stack}";
        if deleteStack "${_stack}" "${ENVIRONMENT}" "${CLIENT}"; then
          cacheStackAsSuccessfullyDeleted "${_stack}";
        fi
      fi
    done
    IFS="${_oldIFS}";
  else
    exitWithErrorCode CANNOT_RETRIEVE_THE_STACK_CHAIN;
  fi
}

# fun: retrieveStacksPendingToDelete stack chain
# api: public
# txt: Retrieves the remaning stacks pending to delete, after the one given, in the chain, in reverse order.
# opt: stack: The first stack to consider in the chain.
# opt: chain: The stack chain.
# txt: Returns 0/TRUE if the stack was in the chain; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the last part of the chain, starting with given stack.
# use: if retrieveStacksPendingForDeletion "permissions" "${CHAIN}"; then
# use:   echo "Remaining: ${RESULT}";
# use: fi
function retrieveStacksPendingToDelete() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _chain="${2}";
  checkNotEmpty chain "${_chain}" 2;

  local -i _rescode=${FALSE};
  local _result;

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _item;
  local -i _includeItem=${FALSE};

  for _item in $(echo ${_chain} | tr -s ' ' '\n' | tac); do
    IFS="${_oldIFS}";
    if areEqual "${_item}" "${_stack}"; then
      _includeItem=${TRUE};
      _rescode=${TRUE};
    fi
    if isTrue ${_includeItem}; then
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_item}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveLastFailedToDeleteStack
# api: public
# txt: Retrieves the last stack that failed to delete.
# txt: Returns 0/TRUE if some stack failed to delete; 1/FALSE otherwise.
# txt: If the function returs 0/TRUE, the variable RESULT contains the failed stack.
# use: if retrieveLastFailedToDeleteStack; then
# use:   echo "Retrying ${RESULT}";
# use: fi
function retrieveLastFailedToDeleteStack() {
  local -i _rescode=${FALSE};
  local _result;

  buildLastFailedToDeleteStackCacheFilename;
  local _cacheFile="${RESULT}";
  if fileExists "${_cacheFile}"; then
    _result="$(cat "${_cacheFile}" 2> /dev/null)";
    _rescode=$?;
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: buildLastFailedToDeleteStackCacheFilename
# api: public
# txt: Builds the filename of the last failed to delete stack cache.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the filename.
# use: buildLastFailedToDeleteStackCacheFilename;
# use: echo "Last failed stack cache file: ${RESULT}";
function buildLastFailedToDeleteStackCacheFilename() {
  export RESULT=".last-failed-to-delete-stack-${ENVIRONMENT}-${CLIENT}";
}

# fun: retrieveCategories
# api: public
# txt: Retrieves the categories.
# txt: Returns 0/TRUE if there's at least one category.
# txt: If the function returns 0/TRUE, the variable RESULT contains the space-separated list of categories.
# use: if retrieveCategories; then
# use:   echo "Categories found: ${RESULT}";
# use: fi
function retrieveCategories() {
  local -i _rescode=${FALSE};
  local _result;

  AWS_DEPLOY.getCachedCategories;
  local _cachedCategories="${RESULT}";

  if isEmpty "${_cachedCategories}"; then
    local _potentialCategories="$(find . -name 'index' | sed 's ^./  g' | grep -v -e '^\..*$' | sort | sed 's /index$  g')";
    local _potentialCategory;
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _potentialCategory in ${_potentialCategories}; do
      IFS="${_oldIFS}";
      if retrieveStacksInCategory "${_potentialCategory}"; then
        _rescode=${TRUE};
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_potentialCategory}";
      fi
    done
    IFS="${_oldIFS}";
    AWS_DEPLOY.setCachedCategories "${_result}";
  else
    _result="${_cachedCategories}";
    _rescode=${TRUE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveCachedStackChain
# api: public
# txt: Retrieves the cached stack chain.
# txt: Returns 0/TRUE if the cached stack chains is available.
# txt: If the function returns 0/TRUE, the variable RESULT contains the cached stack chain.
# use: if retrieveCachedStackChain; then
# use:   echo "chain: ${RESULT}";
# use: fi
function retrieveCachedStackChain() {
  local -i _rescode=${FALSE};
  local _result;

  buildStackChainCacheFilename;
  local _cacheFile="${RESULT}";
  if fileExists "${_cacheFile}"; then
    _result="$(cat "${_cacheFile}" 2> /dev/null)";
    _rescode=$?;
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: buildStackChainCacheFilename
# api: public
# txt: Builds the filename of the stack chain cache.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the filename.
# use: buildStackChainCacheFilename;
# use: echo "Cache file: ${RESULT}";
function buildStackChainCacheFilename() {
  export RESULT=".stack-chain-${ENVIRONMENT}-${CLIENT}";
}

# fun: AWS_DEPLOY.getCachedConfigFiles
# api: private
# txt: Retrieves the cached version of the config files.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedConfigFiles;
# use: local configFiles=${RESULT};
function AWS_DEPLOY.getCachedConfigFiles() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_CONFIG_FILES;
}

# fun: AWS_DEPLOY.setCachedConfigFiles files
# api: private
# txt: Annotates the cached version of the config files.
# txt: files: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedConfigFiles "${files}";
function AWS_DEPLOY.setCachedConfigFiles() {
  local _files="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_CONFIG_FILES "${_files}";
}

# fun: AWS_DEPLOY.getCachedCategories
# api: private
# txt: Retrieves the cached version of the categories.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedCategories;
# use: local configFiles=${RESULT};
function AWS_DEPLOY.getCachedCategories() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_CATEGORIES;
}

# fun: AWS_DEPLOY.setCachedCategories categories
# api: private
# txt: Annotates the cached version of the categories.
# txt: categories: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedCategories "${categories}";
function AWS_DEPLOY.setCachedCategories() {
  local _files="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_CATEGORIES "${_files}";
}

# fun: AWS_DEPLOY.getCachedAwsRegion
# api: private
# txt: Retrieves the cached version of the AWS region.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedAwsRegion;
# use: local awsRegion=${RESULT};
function AWS_DEPLOY.getCachedAwsRegion() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_AWS_REGION;
}

# fun: AWS_DEPLOY.setCachedAwsRegion region
# api: private
# txt: Annotates the cached version of the AWS region.
# txt: region: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedAwsRegion "${region}";
function AWS_DEPLOY.setCachedAwsRegion() {
  local _region="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_AWS_REGION "${_region}";
}

# fun: AWS_DEPLOY.getCachedAwsProfile
# api: private
# txt: Retrieves the cached version of the AWS profile.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedAwsProfile;
# use: local awsProfile=${RESULT};
function AWS_DEPLOY.getCachedAwsProfile() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_AWS_PROFILE;
}

# fun: AWS_DEPLOY.setCachedAwsProfile profile
# api: private
# txt: Annotates the cached version of the AWS profile.
# txt: profile: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedAwsProfile "${profile}";
function AWS_DEPLOY.setCachedAwsProfile() {
  local _profile="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_AWS_PROFILE "${_profile}";
}

# fun: AWS_DEPLOY.defaultState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.defaultState
function AWS_DEPLOY.defaultState() {
  AWS_DEPLOY.setCachedConfigFiles "";
  AWS_DEPLOY.setCachedCategories "";
  AWS_DEPLOY.setCachedAwsRegion "";
  AWS_DEPLOY.setCachedAwsProfile "";
}

# fun: AWS_DEPLOY.resetState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.resetState
function AWS_DEPLOY.resetState() {
  AWS_DEPLOY.getModuleName;
  local _moduleName="${RESULT}";

  # env: CACHED_CONFIG_FILES: The cached config files.
  DW.declareGlobalString "${_moduleName}" CACHED_CONFIG_FILES;

  # env: CACHED_CATEGORIES: The cached categories.
  DW.declareGlobalString "${_moduleName}" CACHED_CATEGORIES;

  # env: CACHED_AWS_REGION: The cached AWS region.
  DW.declareGlobalString "${_moduleName}" CACHED_AWS_REGION;

  # env: CACHED_AWS_REGION: The cached AWS profile.
  DW.declareGlobalString "${_moduleName}" CACHED_AWS_PROFILE;
}

# errors
addError STACK_FOLDER_DOES_NOT_EXIST "stack folder not found";
addError INVALID_CLOUDFORMATION_TEMPLATE "Invalid CloudFormation template";
addError MISSING_STACK_SETTINGS ".config file not found for stack";
addError MISSING_TEMPLATE_FILE "template file not found";
addError MISSING_STACK_INDEX "Missing index for stack ";
addError ERROR_DEPLOYING_STACK "Error deploying stack";
addError ERROR_DELETING_STACK "Error deleting stack";
addError CANNOT_MINIFY_TEMPLATE "Error minifying template";
addError ERROR_CHECKING_STACK_STATUS "Error checking the status of stack";
addError DEPLOY_PRECONDITIONS_NOT_MET "Deploy preconditions not met in stack";
addError DEPLOY_PREHOOK_FAILED "deploy-pre-hook.sh failed";
addError DEPLOY_POSTCONDITIONS_NOT_MET "Deploy postconditions not met in stack";
addError DEPLOY_POSTHOOK_FAILED "deploy-post-hook.sh failed";
addError DELETE_PRECONDITIONS_NOT_MET "Delete preconditions not met in stack";
addError DELETE_PREHOOK_FAILED "delete-pre-hook.sh failed";
addError DELETE_POSTCONDITIONS_NOT_MET "Delete postconditions not met in stack";
addError DELETE_POSTHOOK_FAILED "delete-post-hook.sh failed";

# environment variables
defineEnvVar GIT_COMMIT OPTIONAL "The git commit used when deploying stacks" "b12c68a";
defineEnvVar OMIT_CLIENT_IN_STACK_NAME OPTIONAL "Whether to omit the client in the stack name" ${FALSE};
defineEnvVar OMIT_CONTESTIA_IN_STACK_NAME OPTIONAL "Whether to omit the 'contestia' word in the stack name" ${TRUE};
defineEnvVar OMIT_STACKS OPTIONAL "The comma-separated values of stacks to omit" "";
defineEnvVar STACK_CHECK_INTERVAL OPTIONAL "How often to check for the template deployment to finish" "10s";
defineEnvVar DEFAULT_AWS_PROFILE OPTIONAL "The aws profile" "contestia-devops";
defineEnvVar ECS_TASK_AMBASSADOR_IMAGE OPTIONAL "The ECS-TASK-Lite image" "406021078145.dkr.ecr.eu-west-1.amazonaws.com/ecs-task-kite:latest";

# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
