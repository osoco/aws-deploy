# Copyright 2017-today Osoco S.L.
# Distributed under the terms of the GNU General Public License v3
# mod: deploy-aws.dw
# api: public
# txt: Functions useful for deploying CloudFormation stacks in AWS.

DW.import aws-cli;
DW.import aws-cloudformation;

# fun: AWS_DEPLOY.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: AWS_DEPLOY.getModuleName;
# use: echo "Module: ${RESULT}";
function AWS_DEPLOY.getModuleName() {
  export RESULT="AWS_DEPLOY";
  return ${TRUE};
}

# fun: createOrUpdateStack stack action environment client
# api: public
# txt: Creates or updates a stack.
# opt: stack: The stack.
# opt: action: The action.
# opt: environment: The environment.
# opt: readIncFiles: Whether to read the .inc files. Optional. Defaults to ${TRUE}.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack gets created successfully; 1/${FALSE} otherwise.
# use: if createOrUpdateStack "base/network" create "pre" ${TRUE} "myClient"; then
# use:   echo "Stack base/network, in environment 'pre', for client' myClient', has been created successfully.";
# use: fi
function createOrUpdateStack() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _action="${2}";
  checkNotEmpty action "${_action}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _readIncFiles="${4}";
  if isEmpty "${_readIncFiles}"; then
    _readIncFiles=${TRUE};
  fi
  local _client="${5}";
  local _awsProfile;

  if isTrue "${_readIncFiles}"; then
    readIncFiles "${_environment}" "${_client}";
  fi

  if ! readSettings "${_stack}" "${_environment}" "${_client}"; then
    exitWithErrorCode MISSING_STACK_SETTINGS "${_stack}";
  fi

  buildStackName "${_stack}" "${_environment}" "${_client}";
  export STACK_NAME="${RESULT}";

  if isStackEnabled "${_stack}" "${_environment}" "${_client}"; then

    if ! checkStackDeploymentStatus "${_stack}" "${STACK_NAME}" "${_environment}" "${_client}"; then
      exitWithErrorCode ERROR_CHECKING_STACK_STATUS "${STACK_NAME}";
    fi

    local _status="${RESULT}";
    if areEqual "${_action}" update || ! isStackDeployed "${_status}"; then
      if retrieveAwsProfile "${_stack}" "${_environment}" "${_client}"; then
        _awsProfile="${RESULT}";
      else
        exitWithErrorCode AWS_PROFILE_IS_MANDATORY;
      fi
      
      if ! retrieveTemplateFile "${_stack}"; then
        exitWithErrorCode MISSING_TEMPLATE_FILE "${_stack}/${_stack}.json";
      fi
      local _templateFile="${RESULT}";

      if ! isCloudformationTemplateValid "${_templateFile}" "${_awsProfile}" "${_stack}"; then
        exitWithErrorCode INVALID_CLOUDFORMATION_TEMPLATE "${_templateFile}";
      fi

      if ! runDeployPrehook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_PREHOOK_FAILED "${_stack}";
      fi

      displayDeployPreMessage "${_stack}";

      if ! checkDeployPreconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_PRECONDITIONS_NOT_MET "${_stack}";
      fi

      if ! deployStack "${_awsProfile}" "${STACK_NAME}" "${_stack}" "${_templateFile}" "${_action}" "${_environment}" "${_client}"; then
        exitWithErrorCode ERROR_DEPLOYING_STACK "${_stack}";
      fi

      displayDeployPostMessage "${_stack}";

      if ! runDeployPosthook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_POSTHOOK_FAILED "${_stack}";
      fi

      if ! checkDeployPostconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DEPLOY_POSTCONDITIONS_NOT_MET "${_stack}";
      fi
    fi
  else
    logDebug -n "${_stack}";
    logDebugResult NEUTRAL "skipped";
  fi
}

# fun: readIncFiles environment? client?
# api: public
# txt: Reads / sources the inc files.
# opt: environment: The environment. Optional.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if all files could be read with no error.
# use: if readIncFiles staging; then
# use:   echo "Inc files read successfully";
# use: fi
function readIncFiles() {
  local _environment="${1}";
  local _client="${2}";

  local -i _rescode=${TRUE};

  local _incFiles=( .aws-deploy.inc.sh );
  if isNotEmpty "${_client}"; then
    _incFiles+=( .aws-deploy.inc.sh.${_client} );
  fi

  if isNotEmpty "${_environment}"; then
    _incFiles+=( .aws-deploy.inc.sh.${_environment} );
  fi

  if isNotEmpty "${_environment}" && isNotEmpty "${_client}"; then
    _incFiles+=( .aws-deploy.inc.sh.${_client}-${_environment} );
  fi

  local _oldIFS="${IFS}";
  local _file;
  IFS="${DWIFS}";
  for _file in ${_incFiles[@]}; do
    IFS="${_oldIFS}";
    if fileExists "${_file}"; then
      logTrace -n "Reading ${_file}";
      if source "${_file}"; then
        logTraceResult SUCCESS "done";
      else
        logTraceResult FAILURE "failed";
        _rescode=${FALSE};
        break;
      fi
    fi
  done
  IFS="${_oldIFS}";

  return ${_rescode};
}

# fun: deleteStack stack environment client
# api: public
# txt: Deletes a stack.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if deleteStack "network" "pre" "myClient"; then
# use:   echo "Stack network, in environment 'pre', for client' myClient', has been deleted successfully.";
# use: fi
function deleteStack() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _readIncFiles="${3}";
  if isEmpty "${_readIncFiles}"; then
    _readIncFiles=${TRUE};
  fi
  local _client="${4}";

  if isTrue "${_readIncFiles}"; then
    readIncFiles "${_environment}" "${_client}";
  fi

  if ! readSettings "${_stack}" "${_environment}" "${_client}"; then
    exitWithErrorCode MISSING_STACK_SETTINGS "${_stack}";
  fi

  buildStackName "${_stack}" "${_environment}" "${_client}";
  local _stackName="${RESULT}";

  if isStackEnabled "${_stack}" "${_environment}" "${_client}"; then

    if ! checkStackDeletionStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
      exitWithErrorCode ERROR_CHECKING_STACK_STATUS "${_stackName}";
    fi

    local _status="${RESULT}";
    if isStackDeleted "${_status}"; then
      logDebug -n "${_stack}";
      logDebugResult SUCCESS "already deleted";
    else
      retrieveAwsProfile "${_stack}" "${_environment}" "${_client}";
      local _awsProfile="${RESULT}";

      if ! runDeletePrehook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_PREHOOK_FAILED "${_stack}";
      fi

      displayDeletePreMessage "${_stack}";

      if ! checkDeletePreconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_PRECONDITIONS_NOT_MET "${_stack}";
      fi

      if ! awsDeleteStack "${_awsProfile}" "${_stackName}" "${_environment}" "${_client}"; then
        exitWithErrorCode ERROR_DELETING_STACK "${_stack}";
      fi

      displayDeletePostMessage "${_stack}";

      if ! runDeletePosthook "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_POSTHOOK_FAILED "${_stack}";
      fi

      if ! checkDeletePostconditions "${_awsProfile}" "${_environment}" "${_stack}" "${_client}"; then
        exitWithErrorCode DELETE_POSTCONDITIONS_NOT_MET "${_stack}";
      fi
    fi
  else
    logDebug -n "${_stack}";
    logDebugResult NEUTRAL "skipped";
  fi
}

# fun: awsDeleteStack awsProfile stackName environment client
# api: public
# txt: Requests the deletion of given stack.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if awsDeleteStack "my-profile" "pre-1-my-stack" "pre" "myClient"; then
# use:   echo "pre-1-my-stack deleted successfully in pre";
# use: fi
function awsDeleteStack() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";

  local _region;
  if retrieveAwsRegionForProfile "${_awsProfile}"; then
    _region="${RESULT}";
  else
    _region="eu-west-1";
  fi

  logInfo -n "Requesting the deletion of ${_stackName} in ${_region}";
  requestDeleteStack "${_awsProfile}" "${_stackName}" "${_region}";
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "done";
    waitUntilStackDeletionFinishes "${_stack}" "${_stackName}" "${_environment}" "${_client}";
    _rescode=$?;
  else
    logDebugResult FAILURE "failed";
  fi

  refreshAwsCloudformationExportsCache "${_awsProfile}";

  return ${_rescode};
}

# fun: displayDeployPreMessage stack
# api: public
# txt: Displays a message if the stack includes a pre-deployment message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the message exists and is printed; 1/FALSE otherwise.
# use: displayDeployPreMessage base/network;
function displayDeployPreMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/deploy-pre-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/deploy-pre-message.txt";
  fi
}

# fun: displayDeletePreMessage stack
# api: public
# txt: Displays a message if the stack includes a pre-deletion message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the message exists and is printed; 1/FALSE otherwise.
# use: displayDeletePreMessage base/network;
function displayDeletePreMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/delete-pre-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/delete-pre-message.txt";
  fi
}

# fun: checkDeployPreconditions profile environment stack client?
# api: public
# txt: Checks if the deploy preconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the deploy preconditions are met; 1/FALSE otherwise.
# use: if checkDeployPreconditions dev-myclient dev base/network myclient; then
# use:   echo "Deploy preconditions met";
# use: fi
function checkDeployPreconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/deploy-check-preconditions.sh"; then
    ${_stack}/deploy-check-preconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkDeletePreconditions profile environment stack client?
# api: public
# txt: Checks if the delete preconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the delete preconditions are met; 1/FALSE otherwise.
# use: if checkDeletePreconditions dev-myclient dev base/network myclient; then
# use:   echo "Delete preconditions met";
# use: fi
function checkDeletePreconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/delete-check-preconditions.sh"; then
    ${_stack}/delete-check-preconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeployPrehook profile environment stack client?
# api: public
# txt: Runs any pre-deployment hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeployPrehook dev-myclient dev base/network myclient; then
# use:   echo "Deploy pre hook finished successfully";
# use: fi
function runDeployPrehook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/deploy-pre-hook.sh"; then
    ${_stack}/deploy-pre-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeletePrehook profile environment stack client?
# api: public
# txt: Runs any pre-deletement hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeletePrehook dev-myclient dev base/network myclient; then
# use:   echo "Delete pre hook finished successfully";
# use: fi
function runDeletePrehook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/delete-pre-hook.sh"; then
    ${_stack}/delete-pre-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: displayDeployPostMessage stack
# api: public
# txt: Displays a message if the stack includes a post-deployment message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} always.
# use: displayDeployPostMessage base/network;
function displayDeployPostMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/deploy-post-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/deploy-post-message.txt";
  fi
}

# fun: displayDeletePostMessage stack
# api: public
# txt: Displays a message if the stack includes a post-deletement message file.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} always.
# use: displayDeletePostMessage base/network;
function displayDeletePostMessage() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  if fileExists "${_stack}/delete-post-message.txt"; then
    sed "s|^|[${_stack}] |g" "${_stack}/delete-post-message.txt";
  fi
}

# fun: checkDeployPostconditions profile environment stack client?
# api: public
# txt: Checks if the deploy postconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the deploy postconditions are met; 1/FALSE otherwise.
# use: if checkDeployPostconditions dev-myclient dev base/network myclient; then
# use:   echo "Deploy postconditions met";
# use: fi
function checkDeployPostconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/deploy-check-postconditions.sh"; then
    ${_stack}/deploy-check-postconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: checkDeletePostconditions profile environment stack client?
# api: public
# txt: Checks if the delete postconditions of the stack are met.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the delete postconditions are met; 1/FALSE otherwise.
# use: if checkDeletePostconditions dev-myclient dev base/network myclient; then
# use:   echo "Delete postconditions met";
# use: fi
function checkDeletePostconditions() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/delete-check-postconditions.sh"; then
    ${_stack}/delete-check-postconditions.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeployPosthook profile environment stack client?
# api: public
# txt: Runs any post-deployment hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeployPosthook dev-myclient dev base/network myclient; then
# use:   echo "Deploy post hook finished successfully";
# use: fi
function runDeployPosthook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/deploy-post-hook.sh"; then
    ${_stack}/deploy-post-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: runDeletePosthook profile environment stack client?
# api: public
# txt: Runs any post-deletement hooks for given stack.
# opt: profile: The profile.
# opt: environment: The environment.
# opt: stack: The stack.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the hooks, if any, finish successfully; 1/FALSE otherwise.
# use: if runDeletePosthook dev-myclient dev base/network myclient; then
# use:   echo "Delete post hook finished successfully";
# use: fi
function runDeletePosthook() {
  local _profile="${1}";
  checkNotEmpty profile "${_profile}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _client="${4}";
  checkNotEmpty client "${_client}" 4;

  local -i _rescode=${TRUE};

  if fileExists "${_stack}/delete-post-hook.sh"; then
    ${_stack}/delete-post-hook.sh -p "${_profile}" -e "${_environment}" -c "${_client}";
    _rescode=$?;
  fi

  return ${_rescode};
}

# fun: isStackEnabled stack
# api: public
# txt: Checks whether given stack is enabled or not.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The ctlient.
# txt: Returns 0/TRUE if the stack is enabled; 1/FALSE otherwise.
# use: if isStackEnabled core dev acme; then
# use:   echo "core is enabled in dev environment for acme";
# use: fi
function isStackEnabled() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  checkNotEmpty client "${_client}" 3;

  local -i _rescode=${FALSE};

  local _folder="$(basename ${_stack})";

  if ! fileExists "${_stack}/${_environment}-${_client}.disabled" \
    && fileExists "${_stack}/${_folder}.json"; then
    _rescode=${TRUE};

    local _item;
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _item in $(echo "${OMIT_STACKS}" | sed "s/,/ /g"); do
      IFS="${_oldIFS}";
      if areEqual "${_item}" "${_stack}"; then
        _rescode=${FALSE};
        break;
      fi
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: retrieveDependentStacks stack
# api: public
# txt: Retrieves the dependent stacks.
# opt: stack: The stack name.
# txt: Returns 0/${TRUE} if the dependency analysis succeed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stacks the stack depends on (space-separated values).
# use: if retrieveDependentStacks "dbnetwork"; then
# use:   echo "dbnetwork dependencies: ${RESULT}";
# use: fi
function retrieveDependentStacks() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result="";
  local -i _rescode=${FALSE};
  local _otherStack;

  if fileExists "${_stack}/requirements.yml"; then
    for _otherStack in $(find . -type d | grep -v -e '^\.$' | sed 's ^\./  g' | grep -v -e "^${_stack}$"); do
      grep -e "- ${_otherStack}\W*$" "${_stack}/requirements.yml" > /dev/null;
      local -i _aux=$?;
      if isTrue ${_aux}; then
        _rescode=${TRUE};
        logTrace -n "New dependency found for stack: '${_stack}': ${_otherStack}";
        logTraceResult SUCCESS "${_otherStack}";
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_otherStack}";
      fi
    done
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: deployStack awsProfile stackName stack template action environment client
# api: public
# txt: Requests the deployment of given stack.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: stack: The stack name.
# opt: template: The template file.
# opt: action: Either create or update.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deployed successfully; 1/${FALSE} otherwise.
# use: if deployStack "my-profile" "pre-1-my-stack" "my-stack" "stack.json" create "pre" "myClient"; then
# use:   echo "pre-1-my-stack deployed successfully in pre";
# use: fi
function deployStack() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _template="${4}";
  checkNotEmpty template "${_template}" 4;
  local _action="${5}";
  checkNotEmpty action "${_action}" 5;
  local _environment="${6}";
  checkNotEmpty environment "${_environment}" 6;
  local _client="${7}";

  local _clientTag="";
  if isNotEmpty "${_client}"; then
    _clientTag=" Key=contestia:client,Value=${_client}";
  fi

  local _timestamp="$(date '+%Y%m%d%H%M%S')";
  local -i _rescode=${FALSE};


  if parametersToKeyValuePairs "${_awsProfile}" "${_stackName}" "${_stack}" "${_environment}" "${_client}"; then
    local _parameters="${RESULT}";
    local _region="eu-west-1";
    if retrieveAwsRegion "${_stack}" "${_environment}" "${_client}"; then
      _region="${RESULT}";
    fi
    local _escapedParameters="$(echo "${_parameters}" | sed "s |_quote_| ' g")";
    logTrace "requestCreateOrUpdateStack ${_action} \
                 ${_awsProfile} \
                 ${_stackName} \
                 ${_region} \
                 ${_template} \
                 Key=Name,Value=${_stackName} Key=contestia:name,Value=${_stackName} Key=contestia:environment,Value=${_environment} Key=vendor,Value=Contestia Key=contestia:deploy:template,Value=${_stack} Key=contestia:deploy:template-version,Value=${GIT_COMMIT} Key=contestia:deploy:timestamp,Value=${_timestamp}${_clientTag} \
                 ${_escapedParameters}";

    requestCreateOrUpdateStack "${_action}" \
                               "${_awsProfile}" \
                               "${_stackName}" \
                               "${_region}" \
                               "${_template}" \
                               "Key=Name,Value=${_stackName} Key=contestia:name,Value=${_stackName} Key=contestia:environment,Value=${_environment} Key=vendor,Value=Contestia Key=contestia:deploy:template,Value=${_stack} Key=contestia:deploy:template-version,Value=${GIT_COMMIT} Key=contestia:deploy:timestamp,Value=${_timestamp}${_clientTag}" \
                               "${_escapedParameters}";
    _rescode=$?;
  fi

  local _alreadyExists=${FALSE};
  
  if isFalse ${_rescode}; then
    if contains "${ERROR}" "already exists"; then
      _rescode=${TRUE};
      _alreadyExists=${TRUE};
    elif isNotEmpty "${ERROR}"; then
      logInfo "${_stack} ${_action} error";
      logInfo "${ERROR}";
    fi
  fi

  if isTrue ${_rescode} && isFalse ${_alreadyExists}; then
    waitUntilStackDeploymentFinishes "${_stack}" "${_stackName}" "${_environment}" "${_client}";
    _rescode=$?;
  fi

  refreshAwsCloudformationExportsCache "${_awsProfile}";

  return ${_rescode};
}

# fun: isStackCreated stack environment client
# api: public
# txt: Checks whether given stack is created already.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client.
# txt: Returns 0/${TRUE} if the stack is created correctly; 1/${FALSE} otherwise.
# use: if isStackCreated "network" "pre" "myclient"; then
# use:   echo "Stack network in 'pre', for 'myclient', is created";
# use: fi
function isStackCreated() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local -i _rescode=${FALSE};

  buildStackName "${_stack}" "${_environment}" "${_client}";
  local _stackName="${RESULT}";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _status="${RESULT}";
    if isStackDeployed "${_status}"; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: isStackDeployed status
# api: public
# txt: Checks whether the stack is already deployed.
# opt: status: The stack status.
# txt: Returns 0/TRUE if the stack is deployed; 1/FALSE otherwise.
# use: if isStackDeployed ${status}; then
# use:   echo "Stack deployed";
# use: fi
function isStackDeployed() {
  local _status="${1}";
  checkNotEmpty status "${_status}" 1;

  local -i _rescode;

  if    areEqual "${_status}" CREATE_COMPLETE \
     || areEqual "${_status}" UPDATE_COMPLETE; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};

}

# fun: isStackDeleted status
# api: public
# txt: Checks whether the stack is already deleted.
# opt: status: The stack status.
# txt: Returns 0/TRUE if the stack is deleted; 1/FALSE otherwise.
# use: if isStackDeleted ${status}; then
# use:   echo "Stack deleted";
# use: fi
function isStackDeleted() {
  local _status="${1}";
  checkNotEmpty status "${_status}" 1;

  local -i _rescode;

  if areEqual "${_status}" DELETE_COMPLETE; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};

}

# fun: retrieveStackStatus stack environment stackFullName client
# api: public
# txt: Retrieves the status of a given stack.
# opt: stack: The stack name.
# opt: stackFullName: The full stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the status could be queried; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack status.
# use: if retrieveStackStatus "01-network" "pre-myClient-01-network" "pre" "myClient"; then
# use:   echo "pre-client-01-network status -> ${RESULT}";
# use: fi
function retrieveStackStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackFullName="${2}";
  checkNotEmpty stackFullName "${_stackFullName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${FALSE};
  local _result;
  local _awsProfile;

  if retrieveAwsProfile "${_stack}" "${_environment}" "${_client}"; then
    _awsProfile="${RESULT}";
  else
    exitWithErrorCode CANNOT_USE_AWS_CLI;
  fi

  local _region;
  if retrieveAwsRegionForProfile "${_awsProfile}"; then
    _region="${RESULT}";
  else
    _region="eu-west-1";
  fi

  if checkCloudformationStackStatus "${_stackFullName}" "${_region}" "${_awsProfile}"; then
    _rescode=${TRUE};
    _result="${RESULT:-unknown}";
    if areEqual "${_result}" 'User Initiated'; then
      _result="CREATE_IN_PROGRESS";
    fi
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: checkStackDeploymentStatus stack stackName environment
# api: public
# txt: Checks the status of the stack.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack could be checked; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the status reported by AWS.
# use: if checkStackDeploymentStatus "my-stack" "client-my-stack" "pre" "${CLIENT}"; then
# use:   echo "Stack status -> ${RESULT}";
# use: fi
function checkStackDeploymentStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local _result;

  logTrace -n "Retrieving the status of ${_stack} (${_stackName})";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _result="${RESULT}";

    if isStackDeployed "${_result}"; then
      logTraceResult SUCCESS "${_result}";
    else
      logTraceResult FAILURE "${_result}";
    fi
    export RESULT="${_result}";
  else
    logTraceResult FAILURE "missing";
  fi

  return ${TRUE};
}

# fun: checkStackDeletionStatus stack stackName environment
# api: public
# txt: Checks the status of the stack.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack could be checked; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the status reported by AWS.
# use: if checkStackDeletionStatus "my-stack" "client-my-stack" "pre" "${CLIENT}"; then
# use:   echo "Stack status -> ${RESULT}";
# use: fi
function checkStackDeletionStatus() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local _result;

  logTrace -n "Retrieving the status of ${_stack} (${_stackName})";

  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    local _result="${RESULT}";

    if isStackDeleted "${_result}"; then
      logTraceResult SUCCESS "${_result}";
      export RESULT="${_result}";
    else
      logTraceResult FAILURE "${_result}";
      export ERROR="${_result}";
    fi
  else
    logTraceResult NEUTRAL "missing";
    export RESULT="deleted";
  fi

  return ${TRUE};
}

# fun: waitUntilStackDeploymentFinishes stack stackName environment
# api: public
# txt: Waits until the stack is created or gets rolled back.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets created successfully; 1/${FALSE} otherwise.
# use: if waitUntilStackDeploymentFinishes "my-stack" "pre" "${CLIENT}"; then
# use:   echo "my-stack has been created successfully in pre";
# use: fi
function waitUntilStackDeploymentFinishes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${FALSE};
  local _status;

  logInfo -n "Waiting for ${_stackName} to deploy";
  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    _status="${RESULT}";

    while ! isStackDeployed "${_status}"; do
      if areEqual "${_status}" ROLLBACK_COMPLETE; then
        _rescode=${FALSE};
        break;
      fi
      sleep ${STACK_CHECK_INTERVAL};
      if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
        _status="${RESULT}";
        _rescode=${TRUE};
      else
        _rescode=${FALSE};
        break;
      fi
    done
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "${_status:-unknown}";
  else
    logInfoResult FAILURE "${_status:-unknown}";
  fi

  return ${_rescode};
}

# fun: waitUntilStackDeletionFinishes stack stackName environment
# api: public
# txt: Waits until the stack is deleted.
# opt: stack: The stack.
# opt: stackName: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the stack gets deleted successfully; 1/${FALSE} otherwise.
# use: if waitUntilStackDeletionFinishes "my-stack" "pre" "${CLIENT}"; then
# use:   echo "my-stack has been deleted successfully in pre";
# use: fi
function waitUntilStackDeletionFinishes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _environment="${3}";
  checkNotEmpty environment "${_environment}" 3;
  local _client="${4}";
  local -i _rescode=${TRUE};
  local _status;

  logInfo -n "Waiting for ${_stackName} to be deleted";
  if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
    _status="${RESULT}";

    while ! isStackDeleted "${_status}"; do
      if areEqual "${_status}" DELETE_ROLLBACK_COMPLETE; then
        _rescode=${FALSE};
        break;
      fi
      sleep ${STACK_CHECK_INTERVAL};
      if retrieveStackStatus "${_stack}" "${_stackName}" "${_environment}" "${_client}"; then
        _status="${RESULT}";
        _rescode=${TRUE};
      else
        _rescode=${FALSE};
        break;
      fi
    done
  fi

  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "${_status:-deleted}";
  else
    logInfoResult FAILURE "${_status}";
  fi

  return ${_rescode};
}

# fun: readSettings stack environment
# api: public
# txt: Reads stack settings.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/${TRUE} if the settings are read successfully; 1/${FALSE} otherwise.
# use: if readSettings "my-stack" "pre" "myClient"; then
# use:   echo "my-stack settings read successfully";
# use: fi
function readSettings() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local -i _rescode=${TRUE};
  local _f;

  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    local _configFiles="${RESULT}";
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _f in ${_configFiles}; do
      IFS="${_oldIFS}";
      if fileExists "${_f}"; then
        logTrace -n "Reading ${_f} file";
        source ${_f} 2> /dev/null;
        _rescode=$?;
        if isTrue ${_rescode}; then
          logTraceResult SUCCESS "done";
        else
          logTraceResult FAILURE "failed";
          break;
        fi
      fi
    done
    IFS="${_oldIFS}";
  fi

  return ${_rescode};
}

# fun: retrieveTemplateFile stack
# api: public
# txt: Retrieves the template file.
# opt: stack: The stack name.
# txt: Returns 0/${TRUE} if the template file exists; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the path of the template file.
# use: if retrieveTemplateFile "network"; then
# use:   echo "Template file -> ${RESULT}";
# use: else
# use:   echo "Template file for 'network' not found";
# use: fi
function retrieveTemplateFile() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  local _folder="$(basename ${_stack})";
  _result="${_stack}/${_folder}.json";
  if fileExists "${_result}"; then
    if minifyJsonFile "${_result}"; then
      # RESULT is already exported by minifyJsonFile
      _rescode=${TRUE};
    else
      exitWithErrorCode CANNOT_MINIFY_TEMPLATE "${_result}";
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode};
}

# fun: minifyJsonFile input
# api: public
# txt: Minifies given JSON file.
# opt: input: The JSON to minify.
# txt: Returns 0/${TRUE} if the JSON gets minified; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the path of the minified file.
# use: if minifyJsonFile "/tmp/my-file.json"; then
# use:   echo "Minified file -> ${RESULT}";
# use: else
# use:   echo "Cannot minify /tmp/my-file.json";
# use: fi
function minifyJsonFile() {
  local _input="${1}";
  checkNotEmpty input "${_input}" 1;
  local _result;
  local -i _rescode;

  if createTempFile; then
    _result="${RESULT}";

    jq -c . < "${_input}" > "${_result}" 2> /dev/null
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  else
    logInfo "Error minifying ${_input}";
    jq -c . < "${_input}"
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: buildStackName stack environment client?
# api: public
# txt: Builds the final name for the stack.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Can be empty.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the final name of the stack.
# use: buildStackName "network" "pre" "my_client";
# use: echo "Final name: ${RESULT}";
function buildStackName() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local _result="${_environment}";

  if isNotEmpty "${_client}" && isNotEmpty "${OMIT_CLIENT_IN_STACK_NAME}" && isFalse ${OMIT_CLIENT_IN_STACK_NAME}; then
    _result="${_result}-${_client}";
  fi

  if isNotEmpty "${OMIT_CONTESTIA_IN_STACK_NAME}" && isFalse ${OMIT_CONTESTIA_IN_STACK_NAME}; then
    _result="${_result}-contestia";
  fi

  local _pieces="$(echo ${_stack} | awk -F'/' '{print NF;}')";

  local _oldIFS="${IFS}";
  local _piece;
  local _pieceIndex=0;
  IFS="${DWIFS}";

  for _piece in $(echo "${_stack}" | sed 's|/| |g'); do
    _IFS="${_oldIFS}";
    retrieveNthIndexOfPath "${_stack}" ${_pieceIndex};
    local _index="${RESULT}";
    _result="${_result}-${_index}-${_piece}";
    ((_pieceIndex++));
  done
  _IFS="${_oldIFS}";

  export RESULT="${_result}";
}

# fun: retrieveIndex stack
# api: public
# txt: Retrieves the stack index.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the stack index could be guessed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack index.
# use: if retrieveIndex "network"; then
# use:   echo "Stack index for 'network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the stack index for 'network'";
# use: fi
function retrieveIndex() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  if fileExists "${_stack}/index"; then
    _result="$(cat "${_stack}/index")";
    if isNotEmpty "${_result}"; then
      _rescode=${TRUE};
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveIndexes stack
# api: public
# txt: Retrieves the stack index.
# opt: stack: The stack.
# txt: Returns 0/${TRUE} if the stack index could be guessed; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack index.
# use: if retrieveIndexes "network"; then
# use:   echo "Stack indexes for 'network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the stack index for 'network'";
# use: fi
function retrieveIndexes() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _result;
  local -i _rescode=${FALSE};

  if retrieveIndex "${_stack}"; then
    local -i _pieces="$(echo "${_stack}" | awk -F'/' '{print NF};')";

    local _oldIFS="${IFS}";
    local _piece;
    IFS="${DWIFS}";
    for _piece in $(seq 1 ${_pieces}); do
      IFS="${_oldIFS}";
      local _category="$(echo "${_stack}" | awk -F'/' -v pos=${_piece} '{ for(i=1;i<=pos;i++){ printf("%s/", $i); }}' | sed 's /$  g')";
      if    isNotEmpty "${_category}" \
         && retrieveIndex "${_category}"; then
        _rescode=${TRUE};
        local _index="${RESULT}";
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_index}";
      else
        break;
      fi
    done
    IFS="${_oldIFS}";
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveNthIndexOfPath path nth
# api: public
# txt: Retrieves the nth index of given path.
# opt: path: The path.
# opt: nth: The nth position we are interested in (0-based).
# txt: Returns 0/${TRUE} if the index could be extracted; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the index.
# use: if retrieveNthIndexOfPath "base/network" 2; then
# use:   echo "Index for 'network' in 'base/network' -> ${RESULT}";
# use: else
# use:   echo "Could not find out the index for 'network' in 'base/network'";
# use: fi
function retrieveNthIndexOfPath() {
  local _path="${1}";
  checkNotEmpty path "${_path}" 1;
  local _nth="${2}";
  checkNotEmpty nth "${_nth}" 2;
  checkNumber nth "${_nth}" 2;

  local _result;
  local -i _rescode=${FALSE};

  local -i _pieces="$(echo "${_path}" | awk -F'/' '{print NF};')";

  local _category="$(echo "${_path}" | awk -F'/' -v pos=$((_nth+1)) '{ for(i=1;i<=pos;i++){ printf("%s/", $i); }}' | sed 's /$  g')";
  if    isNotEmpty "${_category}" \
     && retrieveIndex "${_category}"; then
    _rescode=${TRUE};
    _result="${RESULT}";
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveAwsProfile stack enviroment client?
# api: public
# txt: Retrieves the AWS profile.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if the profile was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AWS profile.
# use: if retrieveAwsProfile "network" "${ENVIRONMENT}" "${CLIENT}"; then
# use:   echo "Using profile ${RESULT}";
# use: fi
function retrieveAwsProfile() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local _result;
  local -i _rescode=${FALSE};
  local _f;
  local _oldIFS="${IFS}";

  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    local _configFiles="${RESULT}";
    IFS="${DWIFS}";
    for _f in ${_configFiles}; do
      IFS="${_oldIFS}";
      logTrace -n "Looking for profile information in ${_f}";
      _result="$(grep -e "^AWS_PROFILE=" "${_f}" | awk -F'=' '{print $2}')";
      _rescode=$?;
      if isEmpty "${_result}"; then
        _rescode=${FALSE};
      fi

      if isTrue ${_rescode}; then
        logTraceResult SUCCESS "${_result}";
        break;
      else
        logTraceResult FAILURE "not found";
      fi
    done
    IFS="${_oldIFS}";
  fi

  if isFalse ${_rescode}; then
    normalizeUppercase "${_environment}_${_client}";
    _envUpcased="${RESULT}";
    logTrace -n "Retrieving the default profile for ${_environment} environment (${_envUpcased}_AWS_PROFILE)";
    local -n _aux="${_envUpcased}_AWS_PROFILE";
    _result="${_aux}";
    if isEmpty "${_result}"; then
      logTraceResult NEUTRAL "missing";
      _rescode=${FALSE};
    else
      logTraceResult SUCCESS "${_result}";
      _rescode=${TRUE};
    fi
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
    export RESULT="";
  else
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveAwsRegion stack environment client?
# api: public
# txt: Retrieves the AWS profile.
# opt: stack: The stack name.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if the AWS region could be retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AWS region.
# use: if retrieveAwsRegion "network" "${ENVIRONMENT}" "${CLIENT}"; then
# use:   echo "Using region ${RESULT}";
# use: fi
function retrieveAwsRegion() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";
  local _result;
  local -i _rescode;
  local _f;

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    local _configFiles="${RESULT}";
    for _f in ${_configFiles}; do
      IFS="${_oldIFS}";
      logTrace -n "Looking for region information in ${_f}";
      _result="$(grep -e "^AWS_REGION=" "${_f}" | awk -F'=' '{print $2;}')";
      _rescode=$?;
      if isEmpty "${_result}"; then
        _rescode=${FALSE};
      fi
      
      if isTrue ${_rescode}; then
        logTraceResult SUCCESS "${_result}";
        break;
      else
        logTraceResult FAILURE "not found";
      fi
    done
    IFS="${_oldIFS}";
  fi

  if isFalse ${_rescode}; then
    normalizeUppercase "${_environment}_${_client}";
    _envUpcased="${RESULT}";
    logTrace -n "Retrieving the default region for ${_environment} environment (${_envUpcased}_AWS_REGION)";
    local -n _aux="${_envUpcased}_AWS_REGION";
    _result="${_aux}";
    if isEmpty "${_result}"; then
      logTraceResult NEUTRAL "missing"
	    logTrace "Using 'eu-west-1' as default region";
      _result="eu-west-1";
      _rescode=${TRUE};
    else
      logTraceResult SUCCESS "${_result}";
      _rescode=${TRUE};
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi
  
  return ${_rescode};
}

# fun: retrieveConfigFiles stack environment client?
# api: public
# txt: Retrieves the ordered list of the config files for given stack.
# opt: stack: The name of the stack.
# opt: environment: The environment.
# opt: client: The client. Optional.
# txt: Returns 0/TRUE if at least one config file is found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains a space-separated list of config files.
# use: if retrieveConfigFiles "network" "pre" "client1"; then
# use:   echo "Config files: ${RESULT}";
# use: fi
function retrieveConfigFiles() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _environment="${2}";
  checkNotEmpty environment "${_environment}" 2;
  local _client="${3}";

  local -i _rescode=${FALSE};
  local _result="";
  local _oldIFS="${IFS}";
  local _f;

  AWS_DEPLOY.getCachedConfigFiles;
  local _cachedConfigFiles=""; #"${RESULT}";

  if isEmpty "${_cachedConfigFiles}"; then
    local _folder="$(basename ${_stack})";
    IFS="${DWIFS}";
    for _f in default.config \
                ${_stack}/${_folder}.config \
                ${_environment}.config \
                ${_stack}/${_environment}.config \
                ${_client}.config \
                ${_environment}-${_client}.config \
                ${_stack}/${_client}.config \
                ${_stack}/${_environment}-${_client}.config; do
      IFS="${_oldIFS}";
      logTrace -n "Checking if ${_f} exists";
      if fileExists "${_f}"; then
        logTraceResult SUCCESS "present";
        _rescode=${TRUE};
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_f}";
      else
        logTraceResult NEUTRAL "missing";
      fi
    done;
    IFS="${_oldIFS}";
    AWS_DEPLOY.setCachedConfigFiles "${_result}";
  else
    _result="${_cachedConfigFiles}";
    _rescode=${TRUE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveOptimizedAmiFamily ec2InstanceType
# api: public
# txt: Retrieves the optimized AMI family of the EC2 instances based on their instance type.
# opt: ec2InstanceType: The EC2 instance type. Optional.
# txt: Returns 0/${TRUE} always.
# txt: The variable RESULT contains either "amazon-linux-2", "amazon-linux-2/arm64", "amazon-linux-2/gpu" or "amazon-linux-2/inf".
# use: if retrieveOptimizedAmiFamily "t2.medium"; then
# use:   echo "Optimized AMI family: ${RESULT}";
# use: fi
function retrieveOptimizedAmiFamily() {
  local _instanceType="${1}";

  local _result="amazon-linux-2";

  if isNotEmpty "${_instanceType}"; then
    if contains "${_instanceType}" "a1."; then
      _result="amazon-linux-2/arm64";
    elif contains "${_instanceType}" "m6g."; then
      _result="amazon-linux-2/arm64";
    fi
  fi

  export RESULT="${_result}";

  return ${TRUE};
}

# fun: retrieveImports stackName stack environment client?
# api: public
# txt: Retrieves the imports for a given stack.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if there're imports for given stack; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the contents of a file with variable definitions and their unresolved references.
# use: if retrieveImports "my-profile" "pre-groucho-1-network" "network" "pre" "client1"; then
# use:   echo "Unresolved imports: ${RESULT}";
# use: fi
function retrieveImports() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _environment="${4}";
  checkNotEmpty environment "${_environment}" 4;
  local _client="${5}";

  local -i _rescode=${FALSE};

  local _result="";

  local _files=( "imports.config" );
  if isNotEmpty "${_client}"; then
    _files+=( "${_client}-imports.config" );
  fi
  _files+=( "${_environment}-imports.config" );
  if isNotEmpty "${_client}"; then
    _files+=( "${_environment}-${_client}-imports.config" );
  fi
  local _oldIFS="${IFS}";
  local _file;
  IFS="${DWIFS}";
  for _file in ${_files[@]}; do
    IFS="${_oldIFS}";
    if fileExists "${_stack}/${_file}"; then
      if isNotEmpty "${_result}"; then
        _result="${_result}\n";
      fi
      _result="${_result}$(grep -v -e '^#' ${_stack}/${_file})";
      _rescode=${TRUE};
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: extractStackFromDynamicReference dynamicReference
# api: public
# txt: Given a dynamic reference, it extracts the stack name.
# opt: dynamicReference: The dynamic reference.
# txt: Returns 0/TRUE if the stack name could be extracted; 1/FALSE otherwise.
# use: if extractStackFromDynamicReference "a!b"; then
# use:   echo "Stack: ${RESULT}"; # a
# use: fi
function extractStackFromDynamicReference() {
  local _dynamicReference="${1}";
  checkNotEmpty dynamicReference "${_dynamicReference}" 1;

  AWS_DEPLOY.extractItemFromDynamicReference "${_dynamicReference}" 0;
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: extractOutputFromDynamicReference dynamicReference
# api: public
# txt: Given a dynamic reference, it extracts the stack output.
# opt: dynamicReference: The dynamic reference.
# txt: Returns 0/TRUE if the stack output could be extracted; 1/FALSE otherwise.
# use: if extractOutputFromDynamicReference "a!b"; then
# use:   echo "Output: ${RESULT}"; # b
# use: fi
function extractOutputFromDynamicReference() {
  local _dynamicReference="${1}";
  checkNotEmpty dynamicReference "${_dynamicReference}" 1;

  AWS_DEPLOY.extractItemFromDynamicReference "${_dynamicReference}" 1;
  local -i _rescode=$?;

  return ${_rescode};
}

# fun: AWS_DEPLOY.extractItemFromDynamicReference dynamicReference index
# api: private
# txt: Given a dynamic reference, it extracts the element matching the index.
# opt: dynamicReference: The dynamic reference.
# opt: index: The index (either 0 or 1).
# txt: Returns 0/TRUE if the element could be extracted; 1/FALSE otherwise.
# use: if AWS_DEPLOY.extractItemFromDynamicReference "a!b" 1; then
# use:   echo "Element at 1: ${RESULT}"; # b
# use: fi
function AWS_DEPLOY.extractItemFromDynamicReference() {
  local _dynamicReference="${1}";
  checkNotEmpty dynamicReference "${_dynamicReference}" 1;
  local _index="${2}";
  checkNotEmpty index "${_index}" 2;

  local -i _rescode=${FALSE};
  local _result;

  local -a _pieces;
  if isNumber "${_index}" && split "${_dynamicReference}" "!" _pieces; then
    if nth ${_index} _pieces; then
      _result="${RESULT}";
      if isNotEmpty "${_result}"; then
        _rescode=${TRUE};
      fi
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}


# fun: resolveDynamicReference dynamicReference awsProfile awsRegion environment client?
# api: public
# txt: Resolves a dynamic reference.
# opt: dynamicReference: The dynamic reference.
# opt: awsProfile: The AWS profile.
# opt: awsRegion: The AWS region.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the reference could be resolved successfully; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the resolved reference.
# use: if resolveDynamicReference "base/network!DnsHostedZoneId" "my-profile" "pre" "client1"; then
# use:   echo "Resolved reference: ${RESULT}";
# use: fi
function resolveDynamicReference() {
  local _dynamicReference="${1}";
  checkNotEmpty dynamicReference "${_dynamicReference}" 1;
  local _awsProfile="${2}";
  checkNotEmpty awsProfile "${_awsProfile}" 2;
  local _awsRegion="${3}";
  checkNotEmpty awsRegion "${_awsRegion}" 3;
  local _environment="${4}";
  checkNotEmpty environment "${_environment}" 4;
  local _client="${5}";

  local -i _rescode=${FALSE};
  local _result;

  if extractStackFromDynamicReference "${_dynamicReference}"; then
    local _stack="${RESULT}";

    buildStackName "${_stack}" "${_environment}" "${_client}";
    local _stackName="${RESULT}";

    if extractOutputFromDynamicReference "${_dynamicReference}"; then
      local _output="${RESULT}";

      logDebug -n "Retrieving ${_stackName}-${_output} export in ${_awsRegion}";
      if getCloudformationExport "${_stackName}-${_output}" "${_awsProfile}" "${_awsRegion}"; then
        _result="${RESULT}";
        logDebugResult SUCCESS "${RESULT:-unknown}";
        _rescode=${TRUE};
      else
        logDebugResult FAILURE "${ERROR:-failed}";
      fi

      if   isFalse ${_rescode} \
        && ! areEqual "${_awsRegion}" eu-west-1; then

        logDebug -n "Trying to retrieve ${_stackName}-${_output} export now in eu-west-1";
        if getCloudformationExport "${_stackName}-${_output}" "${_awsProfile}" "eu-west-1" ${TRUE}; then
          _result="${RESULT}";
          logDebugResult SUCCESS "${RESULT:-unknown}";
          _rescode=${TRUE};
        else
          logDebugResult FAILURE "${ERROR:-failed}";
        fi
      fi

      if isFalse ${_rescode}; then
        exitWithErrorCode CANNOT_RETRIEVE_CLOUDFORMATION_EXPORT "${_stackName}-${_output}";
      fi
    else
      logDebug -n "Resolving dynamic stack reference ${_dynamicReference}";
      _result="${_stackName}";
      logDebugResult SUCCESS "${_result}";
      _rescode=${TRUE};
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: resolveImports awsProfile awsRegion stackName stack environment client?
# api: public
# txt: Resolves dynamic imports for a given stack.
# opt: awsProfile: The AWS profile.
# opt: awsRegion: The AWS region.
# opt: stackName: The stack name.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the imports could be resolved successfully; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the contents of a file with variable definitions and their imported values.
# use: if resolveImports "my-profile" eu-west-1 "pre-groucho-1-network" "network" "pre" "client1"; then
# use:   echo "Resolved imports: ${RESULT}";
# use: fi
function resolveImports() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _awsRegion="${2}";
  checkNotEmpty awsRegion "${_awsRegion}" 2;
  local _stackName="${3}";
  checkNotEmpty stackName "${_stackName}" 3;
  local _stack="${4}";
  checkNotEmpty stack "${_stack}" 4;
  local _environment="${5}";
  checkNotEmpty environment "${_environment}" 5;
  local _client="${6}";

  local -i _rescode=${TRUE};

  if retrieveImports "${_awsProfile}" "${_stackName}" "${_stack}" "${_environment}" "${_client}"; then
    local _imports="${RESULT}";

    createTempFile;
    local _tmpFile="${RESULT}";

    local _oldIFS="${IFS}";
    local _import;
    IFS="${DWIFS}";
    for _import in ${_imports}; do
      IFS="${_oldIFS}";
      extractKeyInPair "${_import}";
      local _variableName="${RESULT}";
      extractValueInPair "${_import}";
      local _variableValue="${RESULT}";
      local _dynamicReference="${RESULT}";
      logTrace -n "Resolving dynamic reference ${_variableName}";
      if resolveDynamicReference "${_dynamicReference}" "${_awsProfile}" "${_awsRegion}" "${_environment}" "${_client}"; then
        echo "${_variableName}=${RESULT}" >> "${_tmpFile}";
        logTraceResult SUCCESS "${RESULT}";
      else
        logTraceResult FAILURE "${ERROR:-error}";
        _rescode=${FALSE};
        break;
      fi
    done
    IFS="${_oldIFS}";
  else
    logTrace "No imports found for stack ${_stack}";
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_tmpFile}";
  else
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: parametersToKeyValuePairs stackName stack environment client?
# api: public
# txt: Converts the stack parameters to key=value pairs, key in camel case.
# opt: awsProfile: The AWS profile.
# opt: stackName: The stack name.
# opt: stack: The stack.
# opt: environment: The environment.
# opt: client: The client (optional).
# txt: Returns 0/${TRUE} if the stack parameters could be converted; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the pairs of all parameters defined in deploy-stack.inc.sh.
# use: if parametersToKeyValuePairs "my-profile" "pre-groucho-1-network" "network" "pre" "client1"; then
# use:   echo "'network' parameters: ${RESULT}";
# use: fi
function parametersToKeyValuePairs() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _stackName="${2}";
  checkNotEmpty stackName "${_stackName}" 2;
  local _stack="${3}";
  checkNotEmpty stack "${_stack}" 3;
  local _environment="${4}";
  checkNotEmpty environment "${_environment}" 4;
  local _client="${5}";
  local _otherStacks;
  local _otherStack;
  local _otherStackIndexes;
  local _otherStackName;
  local _camelCasedStackName;
  local _result="";
  local _inputFiles="";
  local -i _rescode;
  local _auxFile;
  local _oldIFS="${IFS}";

  _result="ParameterKey=Environment,ParameterValue=${_environment}";
#  _result="ParameterKey=StackName,ParameterValue=${_stackName}";
  if retrieveDependentStacks "${_stack}"; then
    local _dependentStacks="${RESULT}";
    IFS="${DWIFS}";
    for _otherStack in ${_dependentStacks}; do
      IFS="${_oldIFS}";
      buildStackName "${_otherStack}" "${_environment}" "${_client}";
      _otherStackName="${RESULT}";
      toCamelCase "$(echo ${_otherStack} | tr '[A-Z]' '[a-z]')_stack_name";
      _camelCasedStackName="${RESULT}";
      _result="${_result} ParameterKey=${_camelCasedStackName},ParameterValue=${_otherStackName}";
    done
    IFS="${_oldIFS}";
  fi

  if retrieveConfigFiles "${_stack}" "${_environment}" "${_client}"; then
    _inputFiles="${RESULT}";
    createTempFile;
    _auxFile="${RESULT}";

    IFS="${DWIFS}";
    local _f;
    for _f in ${_inputFiles}; do
      IFS="${_oldIFS}";
      cat ${_f} >> "${_auxFile}";
      echo >> "${_auxFile}";
    done
    IFS="${_oldIFS}";

    local _region="";
    if grep -e "^AWS_REGION=" "${_auxFile}" 2>&1 > /dev/null; then
      _region="$(grep -e "^AWS_REGION=" "${_auxFile}" 2>&1 | head -n 1 | cut -d'=' -f 2)";
    fi

    if isEmpty "${_region}"; then
      if retrieveAwsRegionForProfile "${_awsProfile}"; then
        _region="${RESULT}";
      fi
    fi

    if grep "AMI_ID" "${_auxFile}" 2>&1 > /dev/null; then
      local _ec2InstanceType="$(grep -e "^EC2_INSTANCE_TYPE=" "${_auxFile}" | grep -o '^[^#]*' )";
      retrieveOptimizedAmiFamily "${_ec2InstanceType}";
      local _ec2Architecture="${RESULT}";
      if retrieveOptimizedAmiId "${_awsProfile}" "${_region}" "${_ec2Architecture}"; then
        local _amiId="${RESULT}";
        _result="${_result} ParameterKey=AmiId,ParameterValue=${_amiId}";
      fi
    fi

    if resolveImports "${_awsProfile}" "${_region}" "${_stackName}" "${_stack}" "${_environment}" "${_client}"; then
      local _imports="${RESULT}";
      if isNotEmpty "${_imports}"; then
        cat "${_imports}" >> "${_auxFile}";
      fi
    fi

    preprocessVariableFile "${_auxFile}" "${_stack}/$(basename ${_stack}).json";

    _result="${_result} $(cat "${_auxFile}" | sort -u | uniq | grep -v -e '^#' | grep -v -e '^\s*$' | grep -v 'AWS_PROFILE' | awk -F'=' -v quote="'" '{if (keys[$1] == null || length(keys[$1] == 0)) {print $0;}; keys[$1]=$1;}' | awk -F'=' 'function toCamel(s) { camel = ""; split(s, words, /-|[^a-zA-Z0-9]/); for (i = 1; i in words; i++){camel = camel toupper(substr(words[i], 1, 1)) tolower(substr(words[i], 2)) }; return camel } { gsub(/"/, "", $2); gsub(/^/, quote, $2); gsub(/$/, quote, $2); printf(" ParameterKey=%s,ParameterValue=|_quote_|%s|_quote_|", toCamel($1), $2);}')";
  fi

  export RESULT="${_result}";
}

# fun: preprocessVariableFile file stackFile
# api: public
# txt: Preprocesses given variable file.
# opt: file: The file to process.
# opt: stackFile: The template file.
# txt: Returns 0/TRUE always.
# use: preprocessVariableFile myFile mystack.json;
function preprocessVariableFile() {
  local _file="${1}";
  checkNotEmpty file "${_file}" 1;
  local _stackFile="${2}";
  checkNotEmpty stackFile "${_stackFile}" 2;

  createTempFile;
  local _tmpFile="${RESULT}";

  if awsCloudformationJsonTemplateDefinesParameter "${_stackFile}" "AwsRegion"; then
    logTrace "Respecting AWS_REGION parameter in ${_stackFile}";
    sort -r "${_file}" | grep -v -e '^#' | awk -F'=' '!($1 in a){a[$1];print}' | grep -v AMI_ID > "${_tmpFile}";
  else
    logTrace "Removing AWS_REGION as parameter in ${_stackFile}";
    sort -r "${_file}" | grep -v -e '^#' | awk -F'=' '!($1 in a){a[$1];print}' | grep -v AMI_ID | grep -v AWS_REGION > "${_tmpFile}";
  fi

  cp "${_tmpFile}" "${_file}";
}

# fun: retrieveOptimizedAmiId awsProfile region
# api: public
# txt: Retrieves the id of the optimized AMI for given region.
# opt: awsProfile: The AWS profile.
# opt: region: The region.
# txt: Returns 0/TRUE if the id could be retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the AMI id.
# use: if retrieveOptimizedAmiId "mine" "us-east-1"; then
# use:   echo "AMI ID: ${RESULT}";
# use: fi
function retrieveOptimizedAmiId() {
  local _awsProfile="${1}";
  checkNotEmpty awsProfile "${_awsProfile}" 1;
  local _region="${2}";
  checkNotEmpty region "${_region}" 2;
  local _family="${3}";
  checkNotEmpty family "${_family}" 3;

  local _type;

  local _result;

  _result="$($(which aws) --profile "${_awsProfile}" ssm get-parameters --names /aws/service/ecs/optimized-ami/${_family}/recommended/image_id --region "${_region}" | jq '. | .Parameters[].Value' | tr -d '"')";
  local -i _rescode=$?;
  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveStacksInCategory category
# api: public
# txt: Retrieves the stacks in given category.
# opt: category: The category.
# txt: Returns 0/TRUE if there's any stack in given category.
# txt: If the function returns 0/TRUE, the variable RESULT contains the space-separated list of stacks.
# use: if retrieveStacksInCategory myCategory; then
# use:   echo "Stacks in myCategory: ${RESULT}";
# use: fi
function retrieveStacksInCategory() {
  local _category="${1}";
  checkNotEmpty category "${_category}" 1;

  local -i _rescode=${FALSE};
  local _result;

  local _potentialStacks="$(find ${_category} -maxdepth 1 -type d | sed "s ${_category}/  g" | grep -v -e "^${_category}$")";
  local _potentialStack;
  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  for _potentialStack in ${_potentialStacks}; do
    IFS="${_oldIFS}";
    if fileExists "${_category}/${_potentialStack}/index"; then
      _rescode=${TRUE};
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_potentialStack}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveStackChain
# api: public
# txt: Retrieves the stack chain.
# txt: Returns 0/${TRUE} if the stack chain could be retrieved; 1/${FALSE} otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the stack chain.
# use: if retrieveStackChain; then
# use:   echo "The stack chain is ${RESULT}";
# use: fi
function retrieveStackChain() {
  local _result;
  local -i _rescode=${FALSE};

  if retrieveCachedStackChain; then
    _rescode=${TRUE};
    _result="${RESULT}";
  else
    if retrieveCategories; then
      local _categories="${RESULT}";
      createTempFile;
      local _auxFile="${RESULT}";

      local _category;
      local _categoryIndex=0;
      local _oldIFS="${IFS}";
      IFS="${DWIFS}";
      for _category in ${_categories}; do
        IFS="${_oldIFS}";

        if retrieveIndex "${_category}"; then
          _categoryIndex="${RESULT}";
        else
          exitWithErrorCode CANNOT_RETRIEVE_CATEGORY_INDEX "${_category}";
        fi

        local _stacks="";
        if retrieveStacksInCategory "${_category}"; then
          local _categoryStacks="${RESULT}";
          if isNotEmpty "${_categoryStacks}"; then
            _stacks="${_stacks} ";
          fi
          _stacks="${_stacks}${_categoryStacks}";
        else
          exitWithErrorCode NO_STACKS_IN_CATEGORY_FOUND "${_category}";
        fi
        IFS="${DWIFS}";
        for _stack in ${_stacks}; do
          IFS="${_oldIFS}";
          if isStackEnabled "${_category}/${_stack}" "${ENVIRONMENT}" "${CLIENT}"; then
            if retrieveIndexes "${_category}/${_stack}"; then
              local _stackIndex="";
              _stackIndexes="${RESULT}";
              local _index;
              IFS="${DWIFS}";
              for _index in ${_stackIndexes}; do
                IFS="${_oldIFS}";
                if isNotEmpty "${_index}"; then
                  if isNotEmpty "${_stackIndex}"; then
                    _stackIndex="${_stackIndex}-";
                  fi
                  _stackIndex="${_stackIndex}${_index}";
                fi
              done
              IFS="${_oldIFS}";
            fi
            cat <<EOF >> "${_auxFile}"
${_stackIndex}=${_category}/${_stack}
EOF
          fi
        done
        IFS="${_oldIFS}";
      done

      _result="$(sort "${_auxFile}" | awk -F'=' '{print $2;}')";
      _rescode=$?;
      buildStackChainCacheFilename;
      local _stackOrderFile="${RESULT}";
      sort "${_auxFile}" | awk -F'=' '{print $2;}' > "${_stackOrderFile}";
    else
      exitWithErrorCode NO_CATEGORIES_FOUND;
    fi
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: createAll
# api: public
# txt: Manages the deployment of all stacks as a whole.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: createAll;
function createAll() {
  deployAll create;
}

# fun: updateAll
# api: public
# txt: Manages the update of all stacks as a whole.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: updateAll;
function updateAll() {
  deployAll update;
}

# fun: deployAll action
# api: public
# txt: Manages the deployment of all stacks as a whole.
# opt: action: Either create or update.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: deployAll create;
function deployAll() {
  local _action="${1}";
  checkNotEmpty action "${_action}" 1;

  local _stack;

  readIncFiles "${ENVIRONMENT}" "${CLIENT}";

  if retrieveStackChain; then
    local _chain="${RESULT}";

    if retrieveCurrentStack; then
      local _lastStack="${RESULT}";
      if retrieveStacksPendingToDeploy "${_lastStack}" "${_chain}"; then
        _chain="${RESULT}";
      fi
    fi

    IFS="${DWIFS}";
    for _stack in ${_chain}; do
      IFS="${_oldIFS}";
      if areEqual "${_action}" create; then
        if isStackCreated "${_stack}" "${ENVIRONMENT}" "${CLIENT}"; then
          logInfo -n "${_stack}";
          logInfoResult NEUTRAL "created";
        else
          cacheStackAsFailed "${_stack}";
          if createOrUpdateStack "${_stack}" "${_action}" "${ENVIRONMENT}" ${FALSE} "${CLIENT}"; then
            cacheStackAsSuccessfullyDeployed "${_stack}";
          fi
        fi
      else
        if createOrUpdateStack "${_stack}" "${_action}" "${ENVIRONMENT}" ${FALSE} "${CLIENT}"; then
          cacheStackAsSuccessfullyDeployed "${_stack}";
        fi
      fi
      AWS_DEPLOY.defaultState;
    done
    IFS="${_oldIFS}";
  else
    exitWithErrorCode CANNOT_RETRIEVE_THE_STACK_CHAIN;
  fi
}

# fun: retrieveStacksPendingToDeploy stack chain
# api: public
# txt: Retrieves the remaning stacks after the one given, in the chain.
# opt: stack: The first stack to consider in the chain.
# opt: chain: The stack chain.
# txt: Returns 0/TRUE if the stack was in the chain; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the last part of the chain, starting with given stack.
# use: if retrieveStacksPendingToDeploy "permissions" "${CHAIN}"; then
# use:   echo "Remaining: ${RESULT}";
# use: fi
function retrieveStacksPendingToDeploy() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _chain="${2}";
  checkNotEmpty chain "${_chain}" 2;

  local -i _rescode=${FALSE};
  local _result;

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _item;
  local -i _includeItem=${FALSE};

  for _item in ${_chain}; do
    IFS="${_oldIFS}";
    if areEqual "${_item}" "${_stack}"; then
      _includeItem=${TRUE};
      _rescode=${TRUE};
    fi
    if isTrue ${_includeItem}; then
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_item}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveCurrentStack
# api: public
# txt: Retrieves the current stack.
# txt: Returns 0/TRUE if some stack failed to deploy or delete; 1/FALSE otherwise.
# txt: If the function returs 0/TRUE, the variable RESULT contains the current stack.
# use: if retrieveCurrentStack; then
# use:   echo "Retrying ${RESULT}";
# use: fi
function retrieveCurrentStack() {
  local -i _rescode=${FALSE};
  local _result;

  buildCurrentStackCacheFilename;
  local _cacheFile="${RESULT}";
  if fileExists "${_cacheFile}"; then
    _result="$(cat "${_cacheFile}" 2> /dev/null)";
    _rescode=$?;
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: cacheStackAsFailed stack.
# api: public
# txt: Writes the name of the last failed stack to disk as cache.
# opt: stack: The stack name.
# txt: Returns 0/TRUE if the name of the last failed stack could be cached.
# use: if cacheStackAsFailed myStack; then
# use:   echo "myStack annotated as failed";
# use: fi
function cacheStackAsFailed() {
   local _stack="${1}";
   checkNotEmpty stack "${_stack}" 1;

   local -i _rescode=${FALSE};

   buildCurrentStackCacheFilename;
   local _stackFile="${RESULT}";
   cat <<EOF > "${_stackFile}";
${_stack}
EOF

   return ${_rescode};
 }

# fun: cacheStackAsSuccessfullyDeployed
# api: public
# txt: Ensures given stack is annotated as not failed in the cache.
# txt: Returns 0/TRUE always.
# use: cacheStackAsSuccessfullyDeployed "permissions";
function cacheStackAsSuccessfullyDeployed() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  buildCurrentStackCacheFilename;
  local _stackFile="${RESULT}";
  if cat "${_stackFile}" 2> /dev/null | grep "${_stack}" > /dev/null; then
    echo -n '' > "${_stackFile}";
  fi

  return ${TRUE};
}

# fun: cacheStackAsSuccessfullyDeleted
# api: public
# txt: Ensures given stack is annotated as deleted in the cache.
# txt: Returns 0/TRUE always.
# use: cacheStackAsSuccessfullyDeleted "permissions";
function cacheStackAsSuccessfullyDeleted() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;

  buildCurrentStackCacheFilename;
  local _stackFile="${RESULT}";
  if cat "${_stackFile}" 2> /dev/null | grep "${_stack}" > /dev/null; then
    echo -n '' > "${_stackFile}";
  fi

  return ${TRUE};
}

# fun: deleteAll
# api: public
# txt: Manages the deletion of all stacks as a whole.
# txt: Returns 0/TRUE always. In case of error, it exits.
# use: deleteAll;
function deleteAll() {
  local _stack;

  readIncFiles "${ENVIRONMENT}" "${CLIENT}";

  if retrieveStackChain; then
    local _chain="${RESULT}";

    if retrieveCurrentStack; then
      local _lastStack="${RESULT}";
      if retrieveStacksPendingToDelete "${_lastStack}" "${_chain}"; then
        _chain="$(echo ${RESULT} | tr -s ' ' '\n' | tac)";
      fi
    fi

    IFS="${DWIFS}";
    for _stack in $(echo ${_chain} | tr -s ' ' '\n' | tac); do
      IFS="${_oldIFS}";
      if deleteStack "${_stack}" "${ENVIRONMENT}" ${FALSE} "${CLIENT}"; then
        cacheStackAsSuccessfullyDeleted "${_stack}";
      else
        cacheStackAsFailed "${_stack}";
      fi
    done
    IFS="${_oldIFS}";
  else
    exitWithErrorCode CANNOT_RETRIEVE_THE_STACK_CHAIN;
  fi
}

# fun: retrieveStacksPendingToDelete stack chain
# api: public
# txt: Retrieves the remaning stacks pending to delete, after the one given, in the chain, in reverse order.
# opt: stack: The first stack to consider in the chain.
# opt: chain: The stack chain.
# txt: Returns 0/TRUE if the stack was in the chain; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the last part of the chain, starting with given stack.
# use: if retrieveStacksPendingForDeletion "permissions" "${CHAIN}"; then
# use:   echo "Remaining: ${RESULT}";
# use: fi
function retrieveStacksPendingToDelete() {
  local _stack="${1}";
  checkNotEmpty stack "${_stack}" 1;
  local _chain="${2}";
  checkNotEmpty chain "${_chain}" 2;

  local -i _rescode=${FALSE};
  local _result;

  local _oldIFS="${IFS}";
  IFS="${DWIFS}";
  local _item;
  local -i _includeItem=${FALSE};

  for _item in $(echo ${_chain} | tr -s ' ' '\n' | tac); do
    IFS="${_oldIFS}";
    if areEqual "${_item}" "${_stack}"; then
      _includeItem=${TRUE};
      _rescode=${TRUE};
    fi
    if isTrue ${_includeItem}; then
      if isNotEmpty "${_result}"; then
        _result="${_result} ";
      fi
      _result="${_result}${_item}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: buildCurrentStackCacheFilename
# api: public
# txt: Builds the filename of the last failed stack.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the filename.
# use: buildCurrentStackCacheFilename;
# use: echo "Current stack cache file: ${RESULT}";
function buildCurrentStackCacheFilename() {
  export RESULT=".current-stack-${ENVIRONMENT}-${CLIENT}";
}

# fun: retrieveCategories
# api: public
# txt: Retrieves the categories.
# txt: Returns 0/TRUE if there's at least one category.
# txt: If the function returns 0/TRUE, the variable RESULT contains the space-separated list of categories.
# use: if retrieveCategories; then
# use:   echo "Categories found: ${RESULT}";
# use: fi
function retrieveCategories() {
  local -i _rescode=${FALSE};
  local _result;

  AWS_DEPLOY.getCachedCategories;
  local _cachedCategories="${RESULT}";

  if isEmpty "${_cachedCategories}"; then
    local _potentialCategories="$(find . -name 'index' | sed 's ^./  g' | grep -v -e '^\..*$' | sort | sed 's /index$  g')";
    local _potentialCategory;
    local _oldIFS="${IFS}";
    IFS="${DWIFS}";
    for _potentialCategory in ${_potentialCategories}; do
      IFS="${_oldIFS}";
      if retrieveStacksInCategory "${_potentialCategory}"; then
        _rescode=${TRUE};
        if isNotEmpty "${_result}"; then
          _result="${_result} ";
        fi
        _result="${_result}${_potentialCategory}";
      fi
    done
    IFS="${_oldIFS}";
    AWS_DEPLOY.setCachedCategories "${_result}";
  else
    _result="${_cachedCategories}";
    _rescode=${TRUE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: retrieveCachedStackChain
# api: public
# txt: Retrieves the cached stack chain.
# txt: Returns 0/TRUE if the cached stack chains is available.
# txt: If the function returns 0/TRUE, the variable RESULT contains the cached stack chain.
# use: if retrieveCachedStackChain; then
# use:   echo "chain: ${RESULT}";
# use: fi
function retrieveCachedStackChain() {
  local -i _rescode=${FALSE};
  local _result;

  buildStackChainCacheFilename;
  local _cacheFile="${RESULT}";
  if fileExists "${_cacheFile}"; then
    _result="$(cat "${_cacheFile}" 2> /dev/null)";
    _rescode=$?;
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: buildStackChainCacheFilename
# api: public
# txt: Builds the filename of the stack chain cache.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the filename.
# use: buildStackChainCacheFilename;
# use: echo "Cache file: ${RESULT}";
function buildStackChainCacheFilename() {
  export RESULT=".stack-chain-${ENVIRONMENT}-${CLIENT}";
}

# fun: AWS_DEPLOY.getCachedConfigFiles
# api: private
# txt: Retrieves the cached version of the config files.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedConfigFiles;
# use: local configFiles=${RESULT};
function AWS_DEPLOY.getCachedConfigFiles() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_CONFIG_FILES;
}

# fun: AWS_DEPLOY.setCachedConfigFiles files
# api: private
# txt: Annotates the cached version of the config files.
# txt: files: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedConfigFiles "${files}";
function AWS_DEPLOY.setCachedConfigFiles() {
  local _files="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_CONFIG_FILES "${_files}";
}

# fun: AWS_DEPLOY.getCachedCategories
# api: private
# txt: Retrieves the cached version of the categories.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedCategories;
# use: local configFiles=${RESULT};
function AWS_DEPLOY.getCachedCategories() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_CATEGORIES;
}

# fun: AWS_DEPLOY.setCachedCategories categories
# api: private
# txt: Annotates the cached version of the categories.
# txt: categories: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedCategories "${categories}";
function AWS_DEPLOY.setCachedCategories() {
  local _files="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_CATEGORIES "${_files}";
}

# fun: AWS_DEPLOY.getCachedAwsRegion
# api: private
# txt: Retrieves the cached version of the AWS region.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedAwsRegion;
# use: local awsRegion=${RESULT};
function AWS_DEPLOY.getCachedAwsRegion() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_AWS_REGION;
}

# fun: AWS_DEPLOY.setCachedAwsRegion region
# api: private
# txt: Annotates the cached version of the AWS region.
# txt: region: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedAwsRegion "${region}";
function AWS_DEPLOY.setCachedAwsRegion() {
  local _region="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_AWS_REGION "${_region}";
}

# fun: AWS_DEPLOY.getCachedAwsProfile
# api: private
# txt: Retrieves the cached version of the AWS profile.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.getCachedAwsProfile;
# use: local awsProfile=${RESULT};
function AWS_DEPLOY.getCachedAwsProfile() {
  AWS_DEPLOY.getModuleName;
  DW.getGlobalString "${RESULT}" CACHED_AWS_PROFILE;
}

# fun: AWS_DEPLOY.setCachedAwsProfile profile
# api: private
# txt: Annotates the cached version of the AWS profile.
# txt: profile: The value to cache.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.setCachedAwsProfile "${profile}";
function AWS_DEPLOY.setCachedAwsProfile() {
  local _profile="${1}";

  AWS_DEPLOY.getModuleName;
  DW.setGlobalString "${RESULT}" CACHED_AWS_PROFILE "${_profile}";
}

# fun: AWS_DEPLOY.defaultState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.defaultState
function AWS_DEPLOY.defaultState() {
  AWS_DEPLOY.setCachedConfigFiles "";
  AWS_DEPLOY.setCachedCategories "";
  AWS_DEPLOY.setCachedAwsRegion "";
  AWS_DEPLOY.setCachedAwsProfile "";
}

# fun: AWS_DEPLOY.resetState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: AWS_DEPLOY.resetState
function AWS_DEPLOY.resetState() {
  AWS_DEPLOY.getModuleName;
  local _moduleName="${RESULT}";

  # env: CACHED_CONFIG_FILES: The cached config files.
  DW.declareGlobalString "${_moduleName}" CACHED_CONFIG_FILES;

  # env: CACHED_CATEGORIES: The cached categories.
  DW.declareGlobalString "${_moduleName}" CACHED_CATEGORIES;

  # env: CACHED_AWS_REGION: The cached AWS region.
  DW.declareGlobalString "${_moduleName}" CACHED_AWS_REGION;

  # env: CACHED_AWS_PROFILE: The cached AWS profile.
  DW.declareGlobalString "${_moduleName}" CACHED_AWS_PROFILE;
}

# errors
addError CANNOT_USE_AWS_CLI "Error using AWS CLI. Is the AWS profile (depends on the environment and client) correct?";
addError AWS_PROFILE_IS_MANDATORY "No AWS_PROFILE entry found in any settings file";
addError STACK_FOLDER_DOES_NOT_EXIST "stack folder not found";
addError INVALID_CLOUDFORMATION_TEMPLATE "Invalid CloudFormation template";
addError MISSING_STACK_SETTINGS ".config file not found for stack";
addError MISSING_TEMPLATE_FILE "template file not found";
addError MISSING_STACK_INDEX "Missing index for stack ";
addError ERROR_DEPLOYING_STACK "Error deploying stack";
addError ERROR_DELETING_STACK "Error deleting stack";
addError CANNOT_MINIFY_TEMPLATE "Error minifying template";
addError ERROR_CHECKING_STACK_STATUS "Error checking the status of stack";
addError DEPLOY_PRECONDITIONS_NOT_MET "Deploy preconditions not met in stack";
addError DEPLOY_PREHOOK_FAILED "deploy-pre-hook.sh failed";
addError DEPLOY_POSTCONDITIONS_NOT_MET "Deploy postconditions not met in stack";
addError DEPLOY_POSTHOOK_FAILED "deploy-post-hook.sh failed";
addError DELETE_PRECONDITIONS_NOT_MET "Delete preconditions not met in stack";
addError DELETE_PREHOOK_FAILED "delete-pre-hook.sh failed";
addError DELETE_POSTCONDITIONS_NOT_MET "Delete postconditions not met in stack";
addError DELETE_POSTHOOK_FAILED "delete-post-hook.sh failed";
addError CANNOT_RETRIEVE_CLOUDFORMATION_EXPORT "Cannot retrieve Cloudformation export";

# environment variables
defineEnvVar GIT_COMMIT OPTIONAL "The git commit used when deploying stacks" "b12c68a";
defineEnvVar OMIT_CLIENT_IN_STACK_NAME OPTIONAL "Whether to omit the client in the stack name" ${FALSE};
defineEnvVar OMIT_CONTESTIA_IN_STACK_NAME OPTIONAL "Whether to omit the 'contestia' word in the stack name" ${TRUE};
defineEnvVar OMIT_STACKS OPTIONAL "The comma-separated values of stacks to omit" "";
defineEnvVar STACK_CHECK_INTERVAL OPTIONAL "How often to check for the template deployment to finish" "10s";
defineEnvVar DEFAULT_AWS_PROFILE OPTIONAL "The aws profile" "contestia-devops";
defineEnvVar ECS_TASK_AMBASSADOR_IMAGE OPTIONAL "The ECS-TASK-Lite image" "406021078145.dkr.ecr.eu-west-1.amazonaws.com/ecs-task-kite:latest";

# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
